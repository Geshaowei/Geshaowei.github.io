<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>面试经验</title>
    <link href="/2024/05/15/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    <url>/2024/05/15/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="实践面试经验"><a href="#实践面试经验" class="headerlink" title="实践面试经验"></a>实践面试经验</h1><p>记录自己春招暑假实习和秋招细节的面试经验。</p><h2 id="腾讯天美"><a href="#腾讯天美" class="headerlink" title="腾讯天美"></a>腾讯天美</h2><p>C++基础掌握太差，模板编程不了解。</p><p>TCP UDP</p><p>缺少项目开发经验。</p><h2 id="腾讯光子"><a href="#腾讯光子" class="headerlink" title="腾讯光子"></a>腾讯光子</h2><p>C++基础还行，但是在继承多态中的隐藏理解不深入，以及类的构造函数析构函数不细节。</p><p>面试官：更考察C++或者C#的基础能力。</p><h2 id="游卡-u3d客户端开发"><a href="#游卡-u3d客户端开发" class="headerlink" title="游卡 u3d客户端开发"></a>游卡 u3d客户端开发</h2><p>项目的细节，难点，以及带来的提升。</p><p>class 和 struct的区别。 </p><p>性能优化相关 &#x2F;&#x2F; 说了手动GC，对象池。</p><p>了解粘包吗？ &#x2F;&#x2F;不会。</p><p>细说用到的设计模式，解耦合的使用。</p><p>细说项目对自己学习能力的提升。</p>]]></content>
    
    
    
    <tags>
      
      <tag>面试经验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git-study</title>
    <link href="/2024/05/04/git-study/"/>
    <url>/2024/05/04/git-study/</url>
    
    <content type="html"><![CDATA[<p>git add .  &#x2F;&#x2F;增加 缓存</p><p>git commit -m “”提交本地仓库</p><p>git push origin mian &#x2F;&#x2F;提交原始仓库&#x2F;&#x2F;远程提交 mian分支。</p><p>git merge testbranch 合并分支到当前分支。</p>]]></content>
    
    
    
    <tags>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++Primer</title>
    <link href="/2024/04/26/C-Primer/"/>
    <url>/2024/04/26/C-Primer/</url>
    
    <content type="html"><![CDATA[<h1 id="C-Primer-第六版学习笔记"><a href="#C-Primer-第六版学习笔记" class="headerlink" title="C++ Primer 第六版学习笔记"></a>C++ Primer 第六版学习笔记</h1><p>记录重点难点，易忘、混淆点。</p><p>任务1. c++primer保持一天一个章节，加课后习题<br>任务2. 刷题一天两道，配合学过的c++primer容器和算法去刷够50道开始看labuladong的算法小抄</p><p>总计18章节计划5.10号前搞定任务一。</p><h2 id="Day1-2024-4-26：0-Chapter2-end"><a href="#Day1-2024-4-26：0-Chapter2-end" class="headerlink" title="Day1-2024&#x2F;4&#x2F;26：0-Chapter2-end"></a>Day1-2024&#x2F;4&#x2F;26：0-Chapter2-end</h2><h2 id="Chapter2"><a href="#Chapter2" class="headerlink" title="Chapter2"></a>Chapter2</h2><p>tips：在大型项目中不写 using namespace std 二十using std::cin using std::cout以定向定义某些函数的空间，而不是直接定义所有，防止出现歧义。</p><h2 id="Chapter3"><a href="#Chapter3" class="headerlink" title="Chapter3"></a>Chapter3</h2><p>C++内置的整形-unsigned long 、long、unsigned int、int、unsigned short、short、unsigned char、signed char、bool</p><p>C++11新增：unsigned long long 和 long long</p><p>表示各种整形的系统限制的 climits 文件</p><p>表示各种整型的数字字面值（常量）</p><p>使用const限定符来创建符号常量。</p><p>浮点：float\double\long double</p><p>表示各种浮点类型的系统限制的cfloat 文件</p><p>各种浮雕类型的数字字面值</p><p>自动类型转换 强制类型转换</p><h3 id="简单变量"><a href="#简单变量" class="headerlink" title="简单变量"></a>简单变量</h3><p>short 至少16</p><p>int 至少与short 一样长</p><p>long至少32位，且至少与int一样长</p><p>long long 至少64位，且至少与long一样长</p><h4 id="特殊控制符"><a href="#特殊控制符" class="headerlink" title="特殊控制符"></a>特殊控制符</h4><p>dec\hex\oct 分别指示cout 十进制、十六进制、八进制显示正数</p><p>cout&lt;&lt;hex;\\此后的打印均改变。</p><p>cout&lt;&lt;int_n;</p><h2 id="Chapter4数组"><a href="#Chapter4数组" class="headerlink" title="Chapter4数组"></a>Chapter4数组</h2><p>char   chararray[];&#x2F;&#x2F;  char字符串可直接cout打印，如果未满自动补\0,\0也是string的输出终止条件。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>‘S’是83的另一种写法，但是“S”字符串的写法则代表S和\0组成的字符串，因此用常量不相等，单引号和双引号不能互通。而且”S“ 实际上表示的是字符串所在的内存地址。因此</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> shirt_size = <span class="hljs-string">&quot;S&quot;</span>;  <span class="hljs-comment">//非法的</span><br></code></pre></td></tr></table></figure><p>这试图将一个内存地址赋值给shirt_size;</p><h3 id="指针和自由存储空间"><a href="#指针和自由存储空间" class="headerlink" title="指针和自由存储空间"></a>指针和自由存储空间</h3><p>int *pt &#x3D; new int;&#x2F;&#x2F;自我理解为类似匿名变量，即没有直接表示该数据的变量名称，但是又确实存在这样一块变量地址，唯一访问方法为指针pt访问。</p><p>注意: 正常变量的值都被存在栈的内存区域中，而new 从被成为堆或自由存储区的内存区域分配内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *ps = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>...<br><span class="hljs-keyword">delete</span> ps;<span class="hljs-comment">//释放内存</span><br><span class="hljs-keyword">delete</span> ps;<span class="hljs-comment">//不被允许，因为已经释放。</span><br><span class="hljs-type">int</span> jugs = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> *pi = &amp;jugs;<br><span class="hljs-keyword">delete</span> pi;<span class="hljs-comment">//不被允许 地址不是new分配的内存。</span><br></code></pre></td></tr></table></figure><p>这样会释放ps指向的内存，但是不会删除指针ps本身。</p><h4 id="使用new来创建动态数组"><a href="#使用new来创建动态数组" class="headerlink" title="使用new来创建动态数组"></a>使用new来创建动态数组</h4><p>如果直接声明创建数组，则在被编译时将分配内存空间。此时为静态联遍 static binding。而使用new时，则在运行阶段创建它。这被成为动态联编。dynamic binding。</p><ol><li>不要使用delete 来释放不是new分配的内存</li><li>不要是哟个delete释放同一块内存两次。</li><li>如果用new[] 分配数组则用delete[] 释放</li><li>如果使用new[] 为一个实体分配，则应用delete 来释放</li><li>对空指针 nullptr 应用delete 是安全的。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> *p3 =<span class="hljs-keyword">new</span> <span class="hljs-type">double</span> [<span class="hljs-number">3</span>];<br>p3[<span class="hljs-number">0</span>] = <span class="hljs-number">0.2</span>;<br>p3[<span class="hljs-number">1</span>] = <span class="hljs-number">0.3</span>;<br>p3[<span class="hljs-number">2</span>] = <span class="hljs-number">0.5</span>;<br><span class="hljs-comment">//指针可以当作数组来访问每个元素。</span><br>p3 = p3+<span class="hljs-number">1</span>;<span class="hljs-comment">//不同的是可以改变指针变量指向的第一个值。</span><br><span class="hljs-comment">//现在p3[0]  = 0.3;</span><br></code></pre></td></tr></table></figure><h3 id="指针不同于实体的关键点"><a href="#指针不同于实体的关键点" class="headerlink" title="指针不同于实体的关键点"></a>指针不同于实体的关键点</h3><p>实体对象利用 . 来实现数据和函数的调用，而指向实体的指针可以用-&gt;直接访问实体的数据和函数。&#x2F;&#x2F;自我理解，重载运算符，类似 (*p).函数&#x2F;变量</p><h3 id="string-和-char-类型的-I-O"><a href="#string-和-char-类型的-I-O" class="headerlink" title="string 和 char[]类型的 I&#x2F;O"></a>string 和 char[]类型的 I&#x2F;O</h3><p>char [] -&gt; 可以用 cin.getline(c,n);&#x2F;&#x2F;c代表char * ,n代表长度。</p><p>string str;&#x2F;&#x2F; getline(cin,str);   &#x2F;&#x2F;读取整行，正常的cin读取到 空格或者换行符停止。</p><h2 id="Chapter5循环语句"><a href="#Chapter5循环语句" class="headerlink" title="Chapter5循环语句"></a>Chapter5循环语句</h2><p>“++ * 的关系”</p><p>++运算符级别较高</p><p>++*pt是先取值后加加</p><p>但是<em><em>p</em>++和</em>++pt都是先自加再取值</p><p>关系运算符的优先级不如算数运算符</p><p>x+3&lt;y+3     &#x2F;&#x2F;相当于 (x+3)&lt;(y+3)</p><p>c风格字符串不能用来 &#x3D;&#x3D;，因为其表示的是一个地址，只会比较是否地址相同，应该用strcmp(str1,str2);  str1 &#x3D;&#x3D; str2 时返回 0 否则 &gt; 给 +0</p><p>string对象可以用来 &#x3D;&#x3D; !&#x3D; 因为string类重载了这些运算符。</p><p>逗号表达式   ，  逗号的运算等级最低:  int a &#x3D; 1,2;相当于  int a &#x3D; 1 ;2 在后面被舍弃。int a &#x3D; (1,2); 这种情况使用右值， 即 int a &#x3D;2 ;</p><h2 id="Chapter-if条件逻辑语句"><a href="#Chapter-if条件逻辑语句" class="headerlink" title="Chapter if条件逻辑语句"></a>Chapter if条件逻辑语句</h2><p>&amp;&amp; 和 ||  低于算数运算符，因此一般判断条件不需要加上括号既可以。但是！的优先级优于算数运算符和逻辑运算符，在对表达式取反时要加上括号。</p><h3 id="字符函数库cctype"><a href="#字符函数库cctype" class="headerlink" title="字符函数库cctype"></a>字符函数库cctype</h3><p>继承至ctype.h。 isalpha(ch),如果ch是一个字符 返回一个int类型的非零数。同样如果ch是一个,句号等标点符号，则ispunct(ch)则返回一个非零值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cctype&gt;</span></span><br><span class="hljs-type">char</span> ch;<br><span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27;a&#x27;</span>&lt;=ch&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;z&#x27;</span>||<span class="hljs-string">&#x27;A&#x27;</span>&lt;=ch&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;Z&#x27;</span>)   =&gt;  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isalpha</span>(ch))<br><span class="hljs-built_in">isdigits</span>()=》是否为一个数字<br>isspace 是否为一个空格<br></code></pre></td></tr></table></figure><p>本章节的课后题未作。&#x2F;&#x2F;记得补上</p><h2 id="Chapter7"><a href="#Chapter7" class="headerlink" title="Chapter7"></a>Chapter7</h2><p>函数相关 int add(int * a,int * b);&#x2F;&#x2F;声明函数，指针形式传递地址，数组同样可以传递指针，也可以传递 int a[].使用方式相同。</p><p>函数指针 int (*pf) (int a,int b)；声明一个int返回值，两个int参数的函数指针pf。函数的地址为函数名. pf &#x3D; funname;   (*pf)(a,b);</p><p>typedef int (*pf)(int a,int b);声明一个pf函数指针类型。 pf a; a即为一个pf类型的函数指针。</p><h2 id="Chapter8函数探幽"><a href="#Chapter8函数探幽" class="headerlink" title="Chapter8函数探幽"></a>Chapter8函数探幽</h2><p>int &amp; value &#x3D; a;  value 同 a的值和地址一样。即value是a的别名</p><h3 id="尽可能使用const"><a href="#尽可能使用const" class="headerlink" title="尽可能使用const"></a>尽可能使用const</h3><p>使用const可以避免无意中修改数据的编程错误</p><p>使用const使函数能偶处理const和非const实参，否则将只能接受非const数据</p><p>使用const引用使函数能够正确生成并使用临时变量。</p><p>应尽可能将引用行参声明为const。</p><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>&amp;&amp;声明，即： int &amp;&amp; a &#x3D; 3；</p><h3 id="引用细节"><a href="#引用细节" class="headerlink" title="引用细节"></a>引用细节</h3><p>函数内部临时变量不能作为引用返回，会报错。&#x2F;&#x2F;5.3第八章没学完。后续补</p><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>同命名方法，但是不同参数列表。在一个命名只有一个函数时，函数调用会强制转换类型，使参数类型强制转换。但是重载实现后，参数不匹配时，程序将拒绝调用函数。</p><p>非const可以默认转换const 但是const不能作为参数传递给非const参数。</p><p>如果重载const 和 普通类型，编译器会根据参数是否是const进行调用。</p><p>C++不允许相同参数不同返回值的重载。必须不同参。</p><p>当传递”string”时，这种类型为char *，但是由于为右值，因此参数为const char * 才可以被匹配。如果没有const char * 可以被强制转为string也可以。</p><p>实现重载的底层是编译器会对函数进行名称修饰或者名称矫正</p><p>long myfunction(int a,double b); 会被转化为内部不同的接口表示 ?myfunction@@YAXH</p><h3 id="tamplate函数模板"><a href="#tamplate函数模板" class="headerlink" title="tamplate函数模板"></a>tamplate函数模板</h3><p>tamplate <code>&lt;typename/class T&gt;//typename 和 class二选一，class属于新增标准，但是typename仍然可用,T为自定义类型。名字可以更改。</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//示例函数  模板加函数重载</span><br>tamplate &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testTemplate</span><span class="hljs-params">(T t)</span></span>;<br><span class="hljs-function">tamplate&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testTemplate</span><span class="hljs-params">(T t[],<span class="hljs-type">int</span> n)</span></span>;<br><span class="hljs-comment">//显示具体化模板</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">job</span>&#123;<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> b;<br>string name;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">view_Template</span><span class="hljs-params">(job a)</span></span>; <span class="hljs-comment">//非模板函数</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">view_Template</span><span class="hljs-params">(T a)</span></span>;<span class="hljs-comment">//模板函数</span><br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-type">void</span> <span class="hljs-built_in">view_Template</span>&lt;job&gt;(job a);<span class="hljs-comment">//具体化</span><br><span class="hljs-comment">//调用优先级为 非模板 &gt; 具体化 &gt;模板函数</span><br></code></pre></td></tr></table></figure><p>注意模板并非函数定义，在调用时候才会根据参数生成一个函数实例。（编译器使用模板为特定类型生成函数定义时，得到的是模板实例）</p><p>显示实例化： template void fun <code>&lt;int&gt;(int &amp;a);</code></p><p>隐示实例化：声明模板后的调用会实例化一个相应的函数。</p><p>加上上述的具体化三者统称为具体化。三者表示的都是使用具体类型的函数定义，而不是通用描述。前缀template 和 template&lt;&gt;区分具体化和显示实例化。</p><p>这会直接实例化一个函数，（也叫一个函数定义）。</p><p>显示具体化也会直接实例化。</p><p>auto和decltype的使用</p><p>template <code>&lt;class T1,class T2&gt;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">gt</span><span class="hljs-params">(T1 x,T2y)</span>-&gt;<span class="hljs-title">decltype</span><span class="hljs-params">(x+y)</span></span><br><span class="hljs-function"></span>&#123;<br>... <br><span class="hljs-keyword">return</span> x + y;<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;auto 是一个占位符，由于返回类型不能确定，例如t1是int t2是float，因此decltype关键字可以检测后面表达式或者变量的类型。结合auto可以实现可适应返回类型。指针和引用可以被const和非const重载，但是如果出现两个其他的完全匹配函数则会出现二义性，出现报错。</p><p><img src="/image/C-Primer/1714813712165.png" alt="1714813712165"></p><p>2024.5&#x2F;4结束</p><h2 id="Chapter9内存模型和命名空间"><a href="#Chapter9内存模型和命名空间" class="headerlink" title="Chapter9内存模型和命名空间"></a>Chapter9内存模型和命名空间</h2><p>动态存储：函数内部声明变量</p><p>连接性</p><p>外部链接，内部链接。</p><p>静态存储类型有3种：</p><p>外部链接：函数外声明</p><p>其他文件使用 extern关键词进行引用。</p><p>file1:int cats; file2:extern int cats; &#x2F;&#x2F;否则无法使用同命名数据</p><p>内部链接：函数外static声明</p><p>无连接：函数内static声明</p><p>三种均是静态存储，即函数周期结束存储依旧存在，等同文件周期周期</p><p>const 变量相当于static 声明，函数为内链接。如果要实现外链接，则需要在所有的文件中都加入extern</p><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>namespace 解决函数冲突问题。方便代码管理使用。</p><p>namespace myspace{</p><p>}</p><p>未命名空间</p><p>namespace</p><p>{</p><p>int counts&#x2F;&#x2F;相当于在所属文件中的 static int counts  即静态存储 内部链接。</p><p>}</p><p>在练习题中，其他文件使用namespace 中的函数重载时。需要加上namespace::fun这样才可以使用命名空间中的函数定义。</p><h3 id="using声明和using编译"><a href="#using声明和using编译" class="headerlink" title="using声明和using编译"></a>using声明和using编译</h3><p>using namespace std 为编译，使用所有std空间中的变量和声明。</p><p>using std：：cin   为声明，在当前作用域使用单个声明。</p><h2 id="Chapter10类"><a href="#Chapter10类" class="headerlink" title="Chapter10类"></a>Chapter10类</h2><h3 id="什么是类"><a href="#什么是类" class="headerlink" title="什么是类"></a>什么是类</h3><p>类是用户定义的类型的定义。类似声明指定了数据将如何存储，同时指定了用来访问和操纵这些数据的方法（类成员函数）。</p><p>构造函数:构造函数只会在用户没有定义时提供默认构造函数，如果已经提供则系统不会提供默认构造。</p><p>class A ;A a; a &#x3D; A()。类似这样的赋值，a已经存在，再利用构造函数赋值的时候，会生成一个临时对象，然后进行赋值，之后会调用析构函数删除该临时对象。</p><p>同样，C++允许类和结构一样进行A &#x3D; B赋值。（同类或同结构）。</p><p>类作用域内枚举。 enum class {}</p><p>作用域内的枚举，由于提升了类型安全，不能隐式转换整形</p><p>在类内</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span>&#123;<br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">eggclass</span>&#123;ming,middleg,maxg&#125;;<br><span class="hljs-type">int</span> d = <span class="hljs-built_in">int</span>(eggclass::middleg);<span class="hljs-comment">//不能隐式转化。</span><br><span class="hljs-type">int</span> f = middleg;<span class="hljs-comment">//可以//使用的是类外的普通枚举</span><br>&#125;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">egg</span>&#123;ming,middleg,maxg&#125;;<span class="hljs-comment">//类内外都有ming的枚举类型，但是加上了class会使得eggclass的作用域在类内，并且由于类型安全不会隐式转换int型。</span><br></code></pre></td></tr></table></figure><h2 id="Chapter11使用类"><a href="#Chapter11使用类" class="headerlink" title="Chapter11使用类"></a>Chapter11使用类</h2><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>Time operator +(const Time &amp; t) const;</p><p>Time operator*(double n) const;  &#x2F;&#x2F;都是使用临时对象进行加减乘除，因此使用const限定不改变对象数据。</p><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>友元函数；友元类；友元成员函数；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//创建友元</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Time</span><br>&#123;<br>...<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">friend</span> Time <span class="hljs-keyword">operator</span>* (<span class="hljs-type">double</span> n,<span class="hljs-type">const</span> Time&amp; t);<span class="hljs-comment">//权限与成员函数相同，但是不能使用成员函数的方式访问。且定义不需要friend关键字。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>提示：如果要为类重载运算符，并将非类的项作为其第一个操作符，则可以用友元函数来反转操作数的顺序。</p><p>友元的调用：A &#x3D; n*B  &#x3D;》 A &#x3D; operator *(n,B);</p><p>常用 &lt;&lt; 重载运算符</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">ostream &amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp; os,<span class="hljs-keyword">const</span> Time &amp;t)<br>&#123;<br>os&lt;&lt;t.hours&lt;&lt;<span class="hljs-string">&quot;hours, &quot;</span>&lt;&lt;timinutes<br>&lt;&lt;<span class="hljs-string">&quot; minutes&quot;</span>;<br><span class="hljs-keyword">return</span> os;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后就可以这样打印类 Time : cout&lt;&lt; t; 因为 hours 和minutes是私有的，因此需要将其设置Time的友元函数。</p><p>对于重载运算符，优先使用成员函数，其次再用友元。</p><h3 id="类的自动转换和强制转换"><a href="#类的自动转换和强制转换" class="headerlink" title="类的自动转换和强制转换"></a>类的自动转换和强制转换</h3><p>如果一个类的构造函数只有一个参数，那么 &#x3D; 可以将等式右边的值隐士转换为对象的值。即使用构造函数构造一个临时对象并且赋值给它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">stone</span>&#123;<br><span class="hljs-type">int</span> weight;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">stone</span>(<span class="hljs-type">int</span> nvalue)&#123;weight = nvalue;&#125;<br>&#125;<br>stone A;<br>A = <span class="hljs-number">3</span>;<span class="hljs-comment">//临时构造一个int为3的stone对象，然后赋值给A；</span><br><span class="hljs-keyword">explicit</span> 如果夹在stone构造前，就可以关闭这种特性。<br>使其只可以显示转换，不能隐式转换。<span class="hljs-comment">//只有一个参数或者后面参数有默认值才可以隐式转换。</span><br></code></pre></td></tr></table></figure><h2 id="类和动态内存分配"><a href="#类和动态内存分配" class="headerlink" title="类和动态内存分配"></a>类和动态内存分配</h2><p>12.1.2特殊成员函数</p><ol><li>默认构造函数，如果没有定义构造函数</li><li>默认析构函数，如果没有定义</li><li>复制构造函数，如果没有定义</li><li>赋值运算符，如果没有定义；</li><li>地址运算符，如果没有定义</li></ol><p>复制构造函数：将一个对象复制到新创建的对象。也用于按值传递参数。StringBad(const String &amp;s)&#x2F;&#x2F;复制构造函数的默认形式。默认总是出现浅复制。如果有new的对象则可能会出现两个对象指向同内存空间，导致析构出错。</p><p>&#x2F;&#x2F;在实际使用中，所有初始化赋值的对象都调用的是复制构造函数。只有在初始化之后的 &#x3D; 运算符才是赋值构造函数。</p><p>赋值运算符：使用&#x3D;的时候就有可能调用赋值运算符。</p><p>重载： StringBad &amp; StringBad::operator&#x3D;(const StringBad &amp; st);</p><p>在类中使用new构造时要统一new的使用，并且定义复制构造函数、定义赋值运算符。使得其进行深复制，而不是只复制指针地址。</p><h2 id="Chapter13类继承"><a href="#Chapter13类继承" class="headerlink" title="Chapter13类继承"></a>Chapter13类继承</h2><h3 id="虚函数-virtual"><a href="#虚函数-virtual" class="headerlink" title="虚函数 virtual"></a>虚函数 virtual</h3><p>C++默认编译为静态联编。如果类不会用作基类，则不需要动态联编，同样，如果派生类不重新定义基类的任何方法，也不需要使用动态联编。静态的效率更高。</p><p>C++指导原则之一：不要为不使用的特性付出代价（内存或者处理时间）。</p><p>通常编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中报存了一个指向函数地址数组的指针。这种数组被成为虚函数表。表中存储了为类对象进行声明的虚函数的地址。</p><p>友元：在派生类函数中的同名友元中，强制转换为基类，在用基类的运算符。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>无论在派生类的构造函数中是否显示使用基类的构造函数，派生类的构造函数都会默认先调用基类的构造函数，后调用自身的构造函数。</p><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数的调用顺序相反，默认调用派生类的析构后再调用基类的析构。且调用顺序从最近使用到最远使用。（默认情况）；</p><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>在派生类中可以使用基类的友元函数，常见的是&lt;&lt;运算符，可以使用显示强制转换，将派生类转化为基类，在用 os&lt;&lt;base(baseplus);</p><h3 id="new运算符的使用一定注意"><a href="#new运算符的使用一定注意" class="headerlink" title="new运算符的使用一定注意"></a>new运算符的使用一定注意</h3><p>如果在构造函数中使用了 new</p><p>则析构一定要delete ，并且要对赋值，复制函数重写：operator&#x3D; ,和classname(const classname &amp; cn);</p><h2 id="Chapter14-使用类"><a href="#Chapter14-使用类" class="headerlink" title="Chapter14 使用类"></a>Chapter14 使用类</h2><p>继承，默认私有继承。 class A：B，私有继承，class A：public B。共有。 私有成员只能类中成员函数访问。</p><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>tamplate <code>&lt;class T&gt;</code></p><p>class A</p><p>{</p><p>};</p><p>使用 ，STL中的vector 等容器就是模板类，可以通过&lt;&gt;确定模板类型。同时里面的函数也要用模板函数。</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>dynamic_cast , const_cast static_cast,类型转换比普通类型转换更安全。</p><h2 id="Chapter15友元异常和其他"><a href="#Chapter15友元异常和其他" class="headerlink" title="Chapter15友元异常和其他"></a>Chapter15友元异常和其他</h2><h3 id="Chapter16"><a href="#Chapter16" class="headerlink" title="Chapter16"></a>Chapter16</h3><p>智能指针</p><p>auto_ptr, unique_ptr,shared_ptr.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">unique_ptr&lt;<span class="hljs-type">int</span>&gt;<span class="hljs-built_in">pup</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>)<br><span class="hljs-function">auto_ptr&lt;string&gt; <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-keyword">new</span> string <span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br>shared_ptr&lt;string&gt; stp3;<br>stp3 = stp2;<br>stp3 = <span class="hljs-built_in">shared_ptr</span>&lt;string&gt;(<span class="hljs-keyword">new</span> string <span class="hljs-string">&quot;ss&quot;</span>)<br><span class="hljs-comment">//智能指针的设计就是为了防止程序员遗忘指针对new 出的匿名变量 忘记delete。</span><br><br></code></pre></td></tr></table></figure><p>unique_ptr 和 auto_ptr 都是建立所有权概念，即只能有一个指针持有内存所有权。但是unique_ptr 会在编译阶段就提醒错误，提示语法错误，这是安全于auto_ptr的，并且 unique_ptr 有 new[] 和 delete[] 的配对情况，auto_ptr只有new delete 的情况。</p><p>shared_ptr采用引用计数策略，仅当被被指向对象的引用次数为0时，才会消除对象。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/04/23/cSharp%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/04/23/cSharp%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="By：狸墨"><a href="#By：狸墨" class="headerlink" title="By：狸墨"></a>By：狸墨</h1><h1 id="QQ群：134722347"><a href="#QQ群：134722347" class="headerlink" title="QQ群：134722347"></a>QQ群：134722347</h1><h1 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量命名规范:</p><p>1、 必须以字母或下划线开头，不要以数字开头；</p><p>2、 后面可以跟任意字母、下划线、数字；</p><p>3、 camel命名法：首个单词小写，后面的单词首字母大写；（类名方法名首字母大写）</p><p>4、在变量的作用域内不能再定义同名的变量</p><p>注意：</p><p>　　　　不能以C#中的关键字命名；</p><p>　　　　同一个变量名不能重复定义；</p><p>静态变量：静态变量只需创建一次，在后面程序中可以多次引用，静态变量的初始值就是该变量的默认值，不需要创建其所属类的对象。</p><p>局部变量：在一个独立的程序块中声明的变量，它只在该范围中有效。</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量用来存储固定数值，一旦初始化就不会再改变</p><p>字符常量：</p><table><thead><tr><th align="left">转义序列</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">\</td><td align="left">\ 字符</td></tr><tr><td align="left">&#39;</td><td align="left">‘ 字符</td></tr><tr><td align="left">&quot;</td><td align="left">“ 字符</td></tr><tr><td align="left">?</td><td align="left">? 字符</td></tr><tr><td align="left">\a</td><td align="left">Alert 或 bell</td></tr><tr><td align="left">\b</td><td align="left">退格键（Backspace）</td></tr><tr><td align="left">\f</td><td align="left">换页符（Form feed）</td></tr><tr><td align="left">\n</td><td align="left">换行符（Newline）</td></tr><tr><td align="left">\r</td><td align="left">回车</td></tr><tr><td align="left">\t</td><td align="left">水平制表符 tab</td></tr><tr><td align="left">\v</td><td align="left">垂直制表符 tab</td></tr></tbody></table><p>定义常量: const <data_type> <constant_name> &#x3D; value;</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h2><p>内存分为堆空间和栈空间。</p><p>栈空间比较小，但是读取速度快</p><p>堆空间比较大，但是读取速度慢</p><p>栈的特征：</p><p>   数据只能从栈的顶端插入和删除</p><p>   把数据放入栈顶称为入栈（push）</p><p>   从栈顶删除数据称为出栈（pop）</p><p>堆里的内存能够以任意顺序存入和移除，堆是由系统弹性配置的内存空间，没有特定大小与存活时间，可以被弹性的运用于对象的访问</p><p>数据类型被分为两种：值类型(整数，bool struct char 小数)和引用类型（string 数组 自定义的类，内置的类）。</p><p> 1）值类型只需要一段单独的内存，用于存储实际的数据，（单独定义的时候放在栈中）</p><p> 2）引用类型需要两段内存</p><p> 第一段存储实际的数据，它总是位于堆中</p><p> 第二段是一个引用，指向数据在堆中的存放位置</p><h2 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h2><h3 id="简单类型："><a href="#简单类型：" class="headerlink" title="简单类型："></a>简单类型：</h3><table><thead><tr><th align="left">类型</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left">整数类型</td><td align="left">sbyte、byte、short、ushort、int、uint、long、ulong 和 char</td></tr><tr><td align="left">浮点型</td><td align="left">float 和 double</td></tr><tr><td align="left">十进制类型</td><td align="left">decimal</td></tr><tr><td align="left">布尔类型</td><td align="left">true 或 false 值，指定的值</td></tr><tr><td align="left">空类型</td><td align="left">可为空值的数据类型</td></tr></tbody></table><p>sbyte 有符号整数 存储空间1B,取值范围-128~127</p><p>byte 无符号整数，存储空间1B，取值范围0~255</p><p>short 有符号短整型,存储空间2B，取值范围-32768~+32767</p><p>ushort 无符号短整型，存储空间2B，取值范围0~65535</p><p>int 有符号整型,存储空间4B,取值范围-2^31~2^31</p><p>uint无符号整型,存储空间4B,取值范围0~2^31</p><p>long有符号长整型,存储空间4B,取值范围-2^63~2^63</p><p>ulong无符号长整型,存储空间4B,取值范围0~2^63</p><p>char字符型,存储空间1B,取值范围为 -128 ~ 127</p><p>float 单精度浮点数,存储空间4B,取值范围为-3.4×10^-38～3.4×10^38</p><p>double 双精度浮点数,存储空间8B,取值范围为-1.7×10^-308～1.7×10^308</p><p>decimal 关键字指示 128 位数据类型。 与浮点型相比，decimal 类型具有更高的精度和更小的范围，这使它适合于财务和货币计算</p><h3 id="枚举类型："><a href="#枚举类型：" class="headerlink" title="枚举类型："></a>枚举类型：</h3><p>枚举类型（enum type）是具有一组命名常量的独特的值类型，如果没有显式声明基础类型，则使用 Int32。默认基数从O开始，也可指定数值。</p><h3 id="结构类型："><a href="#结构类型：" class="headerlink" title="结构类型："></a>结构类型：</h3><p>像类一样，结构（struct）是能够包含数据成员和函数成员的数据结构，但是与类不同，结构是值类型，不需要堆分配。结构类型不支持用户指定的继承，并且所有的结构类型都隐式地从类型 object 继承。</p><p>结构是使用 struct 关键字定义的，通常用来封装小类型相关变量组，对小型数据结构而言，使用结构而不是用类会大大节省应用程序分配的量。</p><h3 id="可空类型："><a href="#可空类型：" class="headerlink" title="可空类型："></a>可空类型：</h3><p>可空类型可以表示其基础值类型正常范围内的值，再加上一个 null 值。为了定义一个可空变量类型，在底层数据类型中添加？作为后缀。</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf"><span class="hljs-attribute">&lt; data_type&gt;</span> ? <span class="hljs-attribute">&lt;variable_name&gt;</span> = null;<br></code></pre></td></tr></table></figure><p>Lua：G:\MyTeach\project\LuaWorkSpaceOfMid\src</p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>定义：引用类型不存储它们所代表的实际数据，而是存储对实际数据的引用。引用类型的变量通常称为对象，对象的实例使用new关键字创建，存储在堆中。</p><h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>类是一种包含数据成员、函数成员和嵌套类型的数据结构。</p><p>类的数据成员：常量、域和事件；</p><p>函数成员：方法、属性、索引指示器、运算器、构造函数和析构函数。</p><h4 id="1-自定义类型"><a href="#1-自定义类型" class="headerlink" title="1.自定义类型"></a>1.自定义类型</h4><p>使用Class关键字定义的类型</p><h4 id="2-Object类型"><a href="#2-Object类型" class="headerlink" title="2.Object类型"></a>2.Object类型</h4><p>可以为 Object 的变量分配任何引用类型（字符串、数组、类或接口）。Object 变量还可以引用任何值类型（数值、Boolean、Char、Date、结构或枚举）的数据。</p><p>Object 数据类型可以指向任意数据类型的数据，包括您的应用程序识别的任意对象实例。当您在编译时不知道变量可能指向哪种数据类型时，请使用 Object。</p><h4 id="3-String类型字符串"><a href="#3-String类型字符串" class="headerlink" title="3.String类型字符串"></a>3.String类型字符串</h4><table><thead><tr><th align="left">序号</th><th align="left">属性名称 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>Chars</strong> 在当前 <em>String</em> 对象中获取 <em>Char</em> 对象的指定位置。</td></tr><tr><td align="left">2</td><td align="left"><strong>Length</strong> 在当前的 <em>String</em> 对象中获取字符数。</td></tr></tbody></table><p>C#将字符串视为一个基本类型，它可以申请为一个常量，也可以直接给它赋值。由于C#中的字符串是由System.String类派生而来的引用对象，因此可以使用String类的方法来对字符串进行各种操作。</p><p><strong>字符串的复制：</strong></p><p>​Copy()方法只适用于需要吧某个字符串完整复制到另一个字符串中的情况，相比之下CopyTo（）则比较灵活。</p><p><strong>字符串的比较：</strong></p><p>String类字符串比较大概有4种方法:Compare(),CompareTo(), CompareOrdinal()和Equals(). </p><p>Compare()方法是CompareTo()的静态版本</p><p>而Equals()与”&#x3D;&#x3D;”是等价的,只要使用”&#x3D;&#x3D;”运算符,就会调用Equals()方法。</p><p>CompareOrdinal()对两个字符串进行比较,不考虑本地化语言和文化。</p><p><strong>字符串的查找：</strong></p><p>(1)、String.Contains(Findstr)</p><p>(2)、String.IndexOf(Findstr)</p><p>(3)、String.LastIndexOf(FindStr)</p><p><strong>字符串的截取：</strong></p><p>(1)、String.SubString(StartIndex)<br>(2)、String.SubString(StartIndex, Len)<br><strong>字符串的分割：</strong></p><p>String.Split(SplitCh)</p><p><strong>字符串的合并:</strong></p><p>(1)、String.Concat(str1, str2, …., strn)</p><p>(2)、String.Join(SplitCh, array)</p><p>(3)、用 ‘+’ 来实现</p><p><strong>字符串的长度</strong></p><p>String.Length</p><p>返回长度值</p><p><strong>字符串的替换：</strong></p><p>String.Replace(SreStr, ChangeStr)</p><p><strong>字符串的插入与填充：</strong></p><p>(1)、String.Insert(index, str)</p><p>(2)、String.PadRight(Len, ch)</p><p>(3)、String.PadLeft(Len, ch)</p><p><strong>字符串的删除：</strong></p><p>(1)、String.Trim()</p><p>(2)、string.Trim(Param char[])</p><p>(3)、String.Remove(Start)</p><p>(4)、String.Remove(Start, Len)</p><p><strong>字符串大小写转换：</strong></p><p>(1)、String.ToLower()：将字符串转化为小写形式<br>(2)、String.ToUpper()：将字符串转换成大写形式</p><h4 id="Lua相关"><a href="#Lua相关" class="headerlink" title="Lua相关"></a>Lua相关</h4><p>Lua模式串：与相关的方式配对</p><p>.  任意字符<br>%a  字母<br>%c  控制字符<br>%d  数字<br>%l  小写字母<br>%p  标点字符<br>%s  空白符<br>%u  大写字母<br>%w  字母和数字<br>%x  十六进制数字<br>%z  代表 0的字符 </p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>算数运算符</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">把两个操作数相加</td><td align="left">A + B 将得到 30</td></tr><tr><td align="left">-</td><td align="left">从第一个操作数中减去第二个操作数</td><td align="left">A - B 将得到 -10</td></tr><tr><td align="left">*</td><td align="left">把两个操作数相乘</td><td align="left">A * B 将得到 200</td></tr><tr><td align="left">&#x2F;</td><td align="left">分子除以分母</td><td align="left">B &#x2F; A 将得到 2</td></tr><tr><td align="left">%</td><td align="left">取模运算符，整除后的余数</td><td align="left">B % A 将得到 0</td></tr><tr><td align="left">++</td><td align="left">自增运算符，整数值增加 1</td><td align="left">A++ 将得到 11</td></tr><tr><td align="left">–</td><td align="left">自减运算符，整数值减少 1</td><td align="left">A– 将得到 9</td></tr></tbody></table><p>关系运算符</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&#x3D;&#x3D;</td><td align="left">检查两个操作数的值是否相等，如果相等则条件为真。</td><td align="left">(A &#x3D;&#x3D; B) 不为真。</td></tr><tr><td align="left">!&#x3D;</td><td align="left">检查两个操作数的值是否相等，如果不相等则条件为真。</td><td align="left">(A !&#x3D; B) 为真。</td></tr><tr><td align="left">&gt;</td><td align="left">检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td><td align="left">(A &gt; B) 不为真。</td></tr><tr><td align="left">&lt;</td><td align="left">检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td><td align="left">(A &lt; B) 为真。</td></tr><tr><td align="left">&gt;&#x3D;</td><td align="left">检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td><td align="left">(A &gt;&#x3D; B) 不为真。</td></tr><tr><td align="left">&lt;&#x3D;</td><td align="left">检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td><td align="left">(A &lt;&#x3D; B) 为真。</td></tr></tbody></table><p>逻辑运算符</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&amp;&amp;</td><td align="left">称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td><td align="left">(A &amp;&amp; B) 为假。</td></tr><tr><td align="left">||</td><td align="left">称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td><td align="left">(A || B) 为真。</td></tr><tr><td align="left">!</td><td align="left">称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td><td align="left"></td></tr></tbody></table><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="1-条件分支语句"><a href="#1-条件分支语句" class="headerlink" title="1.条件分支语句"></a>1.条件分支语句</h2><h3 id="If语句"><a href="#If语句" class="headerlink" title="If语句"></a>If语句</h3><p>​最常用的选择语句，根据布尔表达式的值来判断是否执行后面的内嵌语句</p><p>​<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220102152009823.png" alt="image-20220102152009823"></p><h3 id="if…else-语句"><a href="#if…else-语句" class="headerlink" title="if…else 语句"></a><strong>if…else</strong> 语句</h3><p>​<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220102152536123.png" alt="image-20220102152536123"></p><h3 id="if…else-if…else-语句"><a href="#if…else-if…else-语句" class="headerlink" title="**if…else **if…else  语句"></a>**if…else **if…else  语句</h3><p>一个 <strong>if</strong> 语句后可跟一个可选的 <strong>else if…else</strong> 语句，这可用于测试多种条件。</p><p>当使用 if…else if…else 语句时，以下几点需要注意：</p><ul><li>一个 if 后可跟零个或一个 else，它必须在任何一个 else if 之后。</li><li>一个 if 后可跟零个或多个 else if，它们必须在 else 之前。</li><li>一旦某个 else if 匹配成功，其他的 else if 或 else 将不会被测试。</li></ul><h3 id="嵌套-if-语句"><a href="#嵌套-if-语句" class="headerlink" title="嵌套 if 语句"></a>嵌套 if 语句</h3><p>在一个 <strong>if</strong> 或 <strong>else if</strong> 语句内使用另一个 <strong>if</strong> 或 <strong>else if</strong> 语句</p><h3 id="Switch语句"><a href="#Switch语句" class="headerlink" title="Switch语句"></a>Switch语句</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">switch</span>(<span class="hljs-keyword">expression</span>)&#123;<br>    <span class="hljs-keyword">case</span> constant-<span class="hljs-keyword">expression</span>  :<br>       statement(s);<br>       <span class="hljs-keyword">break</span>; <br>    <span class="hljs-keyword">case</span> constant-<span class="hljs-keyword">expression</span>  :<br>       statement(s);<br>       <span class="hljs-keyword">break</span>; <br>  <br>    <span class="hljs-comment">/* 您可以有任意数量的 case 语句 */</span><br>    <span class="hljs-keyword">default</span> : <span class="hljs-comment">/* 可选的 */</span><br>       statement(s);<br>       <span class="hljs-keyword">break</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>switch</strong> 语句必须遵循下面的规则：</p><ul><li><p><strong>switch</strong> 语句中的 <strong>expression</strong> 必须是一个整型或枚举类型，或者是一个 class 类型，其中 class 有一个单一的转换函数将其转换为整型或枚举类型。</p></li><li><p>在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。</p></li><li><p>case 的 <strong>constant-expression</strong> 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量。</p></li><li><p>当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 <strong>break</strong> 语句为止。</p></li><li><p>当遇到 <strong>break</strong> 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。</p></li><li><p>不是每一个 case 都需要包含 <strong>break</strong>。如果 case 语句为空，则可以不包含 <strong>break</strong>，控制流将会继续后续的 case，直到遇到 break 为止。</p></li><li><p>C# 不允许从一个开关部分继续执行到下一个开关部分。如果 case 语句中有处理语句，则必须包含 <strong>break</strong> 或其他跳转语句。</p></li><li><p>一个 <strong>switch</strong> 语句可以有一个可选的 <strong>default</strong> case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 <strong>break</strong> 语句不是必需的。</p></li><li><p>C# 不支持从一个 case 标签显式贯穿到另一个 case 标签。如果要使 C# 支持从一个 case 标签显式贯穿到另一个 case 标签，可以使用 goto 一个 switch-case 或 goto default。</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220102162123165.png" alt="image-20220102162123165"></p></li></ul><h2 id="2-循环控制语句"><a href="#2-循环控制语句" class="headerlink" title="2.循环控制语句"></a>2.循环控制语句</h2><h3 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220102163936562.png" alt="image-20220102163936562"></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">while</span>(condition)<br>&#123;<br>   <span class="hljs-built_in">statement</span>(s);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>statement(s)</strong> 可以是一个单独的语句，也可以是几个语句组成的代码块。<strong>condition</strong> 可以是任意的表达式，当为任意非零值时都为真。当条件为真时执行循环。</p><h3 id="do-while循环语句"><a href="#do-while循环语句" class="headerlink" title="do..while循环语句"></a>do..while循环语句</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220102165734047.png" alt="image-20220102165734047"></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">do<br>&#123;<br>   <span class="hljs-built_in">statement</span>(s);<br><br>&#125;<span class="hljs-built_in">while</span>( condition );<br></code></pre></td></tr></table></figure><p><strong>do…while</strong> 循环是在循环的尾部检查它的条件。</p><p><strong>do…while</strong> 循环与 while 循环类似，但是 do…while 循环会确保至少执行一次循环。</p><h3 id="for-foreach循环语句"><a href="#for-foreach循环语句" class="headerlink" title="for&#x2F;foreach循环语句"></a>for&#x2F;foreach循环语句</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220102170831332.png" alt="image-20220102170831332"></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">for ( init; condition; increment )<br>&#123;<br>   <span class="hljs-built_in">statement</span>(s);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h3><table><thead><tr><th align="left">控制语句</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">break 语句</td><td align="left">终止 <strong>loop</strong> 或 <strong>switch</strong> 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。</td></tr><tr><td align="left">continue 语句</td><td align="left">引起循环跳过主体的剩余部分，立即重新开始测试条件。</td></tr></tbody></table><p>break语句</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220102171632180.png" alt="image-20220102171632180"></p><p>continue语句</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220102171815679.png" alt="image-20220102171815679"></p><p>return</p><p>主要用在函数返回结果，或者结束一个函数的执行</p><p>return只能写在语句块的最后，return执行了之后的所有语句都不会执行</p><h3 id="排序的应用"><a href="#排序的应用" class="headerlink" title="排序的应用"></a>排序的应用</h3><p>1）冒泡排序：通过不断的将相邻的两个数进行大小比较，大的数不断的往后面的位置交换，小的数向数组的顶部位置浮动。</p><p>3）选择排序：通过交换排序的方式，将某个范围内的最小数提到该范围内的第一位。</p><h3 id="质数的判断"><a href="#质数的判断" class="headerlink" title="质数的判断"></a>质数的判断</h3><p>​质数又称素数，是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。质数的个数是无限的;它的约数只有1和它本身;所有大于10的质数中，个位数只有1，3，7，9。</p><p>​合数是指在大于1的整数中，除了能被1和本身整除外，还能被其他非零整数整除的数。所有大于2的偶数都是合数;所有大于5的奇数中，个位为5的都是合数;除O以外，所有个位为O的自然数都是合数;所有个位为4，6，8的自然数都是合数;最小的合数为4，最小的奇合数为9;每一个合数都可以以唯一形式被写成质数的乘积，即分解质因数。</p><h1 id="方法及重载"><a href="#方法及重载" class="headerlink" title="方法及重载"></a>方法及重载</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><strong>定义：</strong>在类的内部定义的，并且可以在类或类的实例上运行的具有某个特定功能的模块。</p><p><strong>C#方法必须包含以下3个部分：</strong></p><p>1.方法的名称</p><p>2.方法的返回值类型</p><p>3.方法的主体</p><p>语法如下：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">&lt;Access Specifier&gt; &lt;Return <span class="hljs-keyword">Type</span>&gt; &lt;<span class="hljs-keyword">Method</span> <span class="hljs-title function_">Name</span>&gt;<span class="hljs-params">(Parameter List)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">   Method Body</span><br><span class="hljs-comment">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><strong>Access Specifier</strong>：访问修饰符，这个决定了变量或方法对于另一个类的可见性。</li><li><strong>Return type</strong>：返回类型，一个方法可以返回一个值。返回类型是方法返回的值的数据类型。如果方法不返回任何值，则返回类型为 <strong>void</strong>。</li><li><strong>Method name</strong>：方法名称，是一个唯一的标识符，且是大小写敏感的。它不能与类中声明的其他标识符相同。</li><li><strong>Parameter list</strong>：参数列表，使用圆括号括起来，该参数是用来传递和接收方法的数据。参数列表是指方法的参数类型、顺序和数量。参数是可选的，也就是说，一个方法可能不包含参数。</li><li><strong>Method body</strong>：方法主体，包含了完成任务所需的指令集。</li></ul><h3 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h3><p>一个方法可以自我调用</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><table><thead><tr><th align="left">方式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">值参数</td><td align="left">这是参数传递的默认方式。在这种方式下，当调用一个方法时，会为每个值参数创建一个新的存储位置。这种方式复制参数的实际值给函数的形式参数，实参和形参使用的是两个不同内存中的值。在这种情况下，当形参的值发生改变时，不会影响实参的值，从而保证了实参数据的安全。</td></tr><tr><td align="left">引用参数</td><td align="left">引用参数是一个对变量的内存位置的引用。这种方式复制参数的内存位置的引用给形式参数。这意味着，当形参的值发生改变时，同时也改变实参的值。在 C# 中，使用 <strong>ref</strong> 关键字声明引用参数。</td></tr><tr><td align="left">输出参数</td><td align="left">输出参数会把方法输出的数据赋给自己，其他方面与引用参数相似。这种方式可以返回多个值。使用 <strong>out</strong> 关键字声明输出参数</td></tr></tbody></table><h3 id="参数数组"><a href="#参数数组" class="headerlink" title="参数数组"></a>参数数组</h3><p>Params关键字：允许将相同类型数量可变的多个参数传给一个方法</p><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>使用规则：</p><p>1.可选参数不能为参数列表的第一个参数，它必须位于所有必选参数之后</p><p>2.可选参数必须指定一个默认值</p><p>3.可选参数的默认值必须是一个常量表达式</p><p>4.所有可选参数以后的参数都必须是可选参数</p><h2 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h2><p>方法的重载即在同一类的内部可以定义同名方法，但这些同名方法的参数列表必须不同，以便在用户调用方法的时候能够自动识别应调用的方法。</p><h1 id="表"><a href="#表" class="headerlink" title="表"></a>表</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是一个存储相同类型元素的固定大小的顺序集合。数组是用来存储数据的集合，通常认为数组是一个同一类型变量的集合。</p><p>声明数组变量并不是声明 number0、number1、…、number99 一个个单独的变量，而是声明一个就像 numbers 这样的变量，然后使用 numbers[0]、numbers[1]、…、numbers[99] 来表示一个个单独的变量。数组中某个指定的元素是通过索引来访问的。</p><p>所有的数组都是由连续的内存位置组成的。最低的地址对应第一个元素，最高的地址对应最后一个元素。</p><p>数组的声明：datatype[] arrayName</p><h3 id="多维数组："><a href="#多维数组：" class="headerlink" title="多维数组："></a><img src="G:\MyTeach\project\CSharpAndLua\学习文档\12维数组.jpg" alt="12维数组">多维数组：</h3><p><img src="G:\MyTeach\project\CSharpAndLua\学习文档\多维数组.jpg" alt="多维数组"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> [ , , ] m;<br></code></pre></td></tr></table></figure><h3 id="交错数组："><a href="#交错数组：" class="headerlink" title="交错数组："></a>交错数组：</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">int <span class="hljs-selector-attr">[]</span><span class="hljs-selector-attr">[]</span> scores;<br></code></pre></td></tr></table></figure><h3 id="Array类"><a href="#Array类" class="headerlink" title="Array类"></a>Array类</h3><p>常用属性：</p><table><thead><tr><th align="left">序号</th><th align="left">属性 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>IsFixedSize</strong> 获取一个值，该值指示数组是否带有固定大小。</td></tr><tr><td align="left">2</td><td align="left"><strong>IsReadOnly</strong> 获取一个值，该值指示数组是否只读。</td></tr><tr><td align="left">3</td><td align="left"><strong>Length</strong> 获取一个 32 位整数，该值表示所有维度的数组中的元素总数。</td></tr><tr><td align="left">4</td><td align="left"><strong>LongLength</strong> 获取一个 64 位整数，该值表示所有维度的数组中的元素总数。</td></tr><tr><td align="left">5</td><td align="left"><strong>Rank</strong> 获取数组的秩（维度）。</td></tr></tbody></table><p>常用方法：</p><table><thead><tr><th align="left">序号</th><th align="left">方法 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>Clear</strong> 根据元素的类型，设置数组中某个范围的元素为零、为 false 或者为 null。</td></tr><tr><td align="left">2</td><td align="left"><strong>Copy(Array, Array, Int32)</strong> 从数组的第一个元素开始复制某个范围的元素到另一个数组的第一个元素位置。长度由一个 32 位整数指定。</td></tr><tr><td align="left">3</td><td align="left"><strong>CopyTo(Array, Int32)</strong> 从当前的一维数组中复制所有的元素到一个指定的一维数组的指定索引位置。索引由一个 32 位整数指定。</td></tr><tr><td align="left">4</td><td align="left"><strong>GetLength</strong> 获取一个 32 位整数，该值表示指定维度的数组中的元素总数。</td></tr><tr><td align="left">5</td><td align="left"><strong>GetLongLength</strong> 获取一个 64 位整数，该值表示指定维度的数组中的元素总数。</td></tr><tr><td align="left">6</td><td align="left"><strong>GetLowerBound</strong> 获取数组中指定维度的下界。</td></tr><tr><td align="left">7</td><td align="left"><strong>GetType</strong> 获取当前实例的类型。从对象（Object）继承。</td></tr><tr><td align="left">8</td><td align="left"><strong>GetUpperBound</strong> 获取数组中指定维度的上界。</td></tr><tr><td align="left">9</td><td align="left"><strong>GetValue(Int32)</strong> 获取一维数组中指定位置的值。索引由一个 32 位整数指定。</td></tr><tr><td align="left">10</td><td align="left"><strong>IndexOf(Array, Object)</strong> 搜索指定的对象，返回整个一维数组中第一次出现的索引。</td></tr><tr><td align="left">11</td><td align="left"><strong>Reverse(Array)</strong> 逆转整个一维数组中元素的顺序。</td></tr><tr><td align="left">12</td><td align="left"><strong>SetValue(Object, Int32)</strong> 给一维数组中指定位置的元素设置值。索引由一个 32 位整数指定。</td></tr><tr><td align="left">13</td><td align="left"><strong>Sort(Array)</strong> 使用数组的每个元素的 IComparable 实现来排序整个一维数组中的元素。</td></tr><tr><td align="left">14</td><td align="left"><strong>ToString</strong> 返回一个表示当前对象的字符串。从对象（Object）继承。</td></tr></tbody></table><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>它可以使用键和索引来访问列表中的项。</p><p>排序列表是数组和哈希表的组合。它包含一个可使用键或索引访问各项的列表。如果您使用索引访问各项，则它是一个动态数组（ArrayList），如果您使用键访问各项，则它是一个哈希表（Hashtable）。集合中的各项总是按键值排序。</p><h3 id="1-创建列表"><a href="#1-创建列表" class="headerlink" title="1.创建列表"></a>1.创建列表</h3><p>列表可以存储任何类型的数据，在创建列表对象的时候首先要指定你要创建的这个列表要存储什么类型的（泛型）</p><h3 id="2-遍历列表"><a href="#2-遍历列表" class="headerlink" title="2.遍历列表"></a>2.遍历列表</h3><p>for循环，遍历所有的索引，通过索引访问列表中的元素</p><p>foreach遍历</p><h3 id="3-列表的常用属性方法"><a href="#3-列表的常用属性方法" class="headerlink" title="3.列表的常用属性方法"></a>3.列表的常用属性方法</h3><p><strong>1.Capacity获取容量大小,Count获取数组元素个数</strong></p><ul><li><p>Capacity 是列表之前设定的容量值；</p></li><li><p>Count 是实际的元素个数。</p><p>Capacity 总是大于或等于 Count，当 Count 超过 Capacity 后，又自动扩容以装下新的元素。</p></li></ul><p><strong>2.Add()方法添加元素</strong></p><p><strong>3.Insert()方法插入元素</strong></p><p>向指定索引位置插入元素，原来的元素向后移动一位。插入索引不能超出索引范围。</p><p><strong>4.RemoveAt()方法移除指定位置的元素</strong></p><p><strong>5.IndexOf()方法取得一个元素所在列表中的索引位置<br>LastIndexOf()上面的方法是从前往后搜索，这个是从后往前搜索，搜索到满足条件的就停止,上面的两个方法，如果没有找到指定元素就返回-1</strong></p><p><strong>6.Sort()对列表中是元素进行从小到大排序</strong></p><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>注意：必须包含名空间System.Collection.Generic<br>Dictionary里面的每一个元素都是一个键值对(由二个元素组成：键和值)<br>键必须是唯一的,而值不需要唯一的<br>键和值都可以是任何类型(比如：string, int, 自定义类型，等等)<br>通过一个键读取一个值的时间是接近O(1)<br>如果你尝试读取字典中一个不存在的键，那么你会得到一个KeyNotFoundException。所有在读取一个键之前，你必须先使用ContainKey来核对键是否存在字典中。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>使用泛型给代码带来的5点好处：</p><p>1、可以做大限度的重用代码、保护类型的安全以及提高性能。</p><p>2、可以创建集合类。</p><p>3、可以创建自己的泛型接口、泛型方法、泛型类、泛型事件和泛型委托。</p><p>4、可以对泛型类进行约束，以访问特定数据类型的方法。</p><p>5、关于泛型数据类型中使用的类型的信息，可在运行时通过反射获取。</p><p>泛型类的定义：</p><p>访问修饰符 class 类名<T></p><p>{泛型类成员定义}</p><p>泛型类对象与创建一般类的对象类似，但不能使用占位符T，必须明确指定一种数据类型替换T</p><p>如：泛型类名<int> 对象名&#x3D;new 泛型类名<int>();</p><p>泛型类成员的 定义可以使用T类型的参数或变量</p><p>如：public void Mysort（T[] a）</p><p><strong>六种类型的约束：</strong></p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>T：结构</td><td>类型参数必须是值类型。可以指定除 Nullable 以外的任何值类型。</td></tr><tr><td>T：类</td><td>类型参数必须是引用类型，包括任何类、接口、委托或数组类型。</td></tr><tr><td>T：new()</td><td>类型参数必须具有无参数的公共构造函数。当与其他约束一起使用时，<strong>new()</strong> 约束必须最后指定。</td></tr><tr><td>T：&lt;基类名&gt;</td><td>类型参数必须是指定的基类或派生自指定的基类。</td></tr><tr><td>T：&lt;接口名称&gt;</td><td>类型参数必须是指定的接口或实现指定的接口。可以指定多个接口约束。约束接口也可以是泛型的。</td></tr><tr><td>T：U</td><td>为 T 提供的类型参数必须是为 U 提供的参数或派生自为 U 提供的参数。这称为裸类型约束。</td></tr></tbody></table><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="非泛型集合类"><a href="#非泛型集合类" class="headerlink" title="非泛型集合类"></a>非泛型集合类</h3><h4 id="1-ArrayList类"><a href="#1-ArrayList类" class="headerlink" title="1.ArrayList类"></a><strong>1.ArrayList类</strong></h4><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Capacity</td><td align="left">获取或设置 ArrayList 可以包含的元素个数。</td></tr><tr><td align="left">Count</td><td align="left">获取 ArrayList 中实际包含的元素个数。</td></tr><tr><td align="left">IsFixedSize</td><td align="left">获取一个值，表示 ArrayList 是否具有固定大小。</td></tr><tr><td align="left">IsReadOnly</td><td align="left">获取一个值，表示 ArrayList 是否只读。</td></tr><tr><td align="left">IsSynchronized</td><td align="left">获取一个值，表示访问 ArrayList 是否同步（线程安全）。</td></tr><tr><td align="left">Item[Int32]</td><td align="left">获取或设置指定索引处的元素。</td></tr><tr><td align="left">SyncRoot</td><td align="left">获取一个对象用于同步访问 ArrayList。</td></tr></tbody></table><table><thead><tr><th>1</th><th><strong>public virtual int Add( object value );</strong> 在 ArrayList 的末尾添加一个对象。</th></tr></thead><tbody><tr><td>2</td><td><strong>public virtual void AddRange( ICollection c );</strong> 在 ArrayList 的末尾添加 ICollection 的元素。</td></tr><tr><td>3</td><td><strong>public virtual void Clear();</strong> 从 ArrayList 中移除所有的元素。</td></tr><tr><td>4</td><td><strong>public virtual bool Contains( object item );</strong> 判断某个元素是否在 ArrayList 中。</td></tr><tr><td>5</td><td><strong>public virtual ArrayList GetRange( int index, int count );</strong> 返回一个 ArrayList，表示源 ArrayList 中元素的子集。</td></tr><tr><td>6</td><td><strong>public virtual int IndexOf(object);</strong> 返回某个值在 ArrayList 中第一次出现的索引，索引从零开始。</td></tr><tr><td>7</td><td><strong>public virtual void Insert( int index, object value );</strong> 在 ArrayList 的指定索引处，插入一个元素。</td></tr><tr><td>8</td><td><strong>public virtual void InsertRange( int index, ICollection c );</strong> 在 ArrayList 的指定索引处，插入某个集合的元素。</td></tr><tr><td>9</td><td><strong>public virtual void Remove( object obj );</strong> 从 ArrayList 中移除第一次出现的指定对象。</td></tr><tr><td>10</td><td><strong>public virtual void RemoveAt( int index );</strong> 移除 ArrayList 的指定索引处的元素。</td></tr><tr><td>11</td><td><strong>public virtual void RemoveRange( int index, int count );</strong> 从 ArrayList 中移除某个范围的元素。</td></tr><tr><td>12</td><td><strong>public virtual void Reverse();</strong> 逆转 ArrayList 中元素的顺序。</td></tr><tr><td>13</td><td><strong>public virtual void SetRange( int index, ICollection c );</strong> 复制某个集合的元素到 ArrayList 中某个范围的元素上。</td></tr><tr><td>14</td><td><strong>public virtual void Sort();</strong> 对 ArrayList 中的元素进行排序。</td></tr><tr><td>15</td><td><strong>public virtual void TrimToSize();</strong> 设置容量为 ArrayList 中元素的实际个数。</td></tr></tbody></table><h4 id="2-Queue类"><a href="#2-Queue类" class="headerlink" title="2.Queue类"></a><strong>2.Queue类</strong></h4><p>代表了一个<strong>先进先出</strong>的对象集合</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Count</td><td align="left">获取 Queue 中包含的元素个数。</td></tr></tbody></table><table><thead><tr><th align="left">序号</th><th align="left">方法名 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>public virtual void Clear();</strong> 从 Queue 中移除所有的元素。</td></tr><tr><td align="left">2</td><td align="left"><strong>public virtual bool Contains( object obj );</strong> 判断某个元素是否在 Queue 中。</td></tr><tr><td align="left">3</td><td align="left"><strong>public virtual object Dequeue();</strong> 移除并返回在 Queue 的开头的对象。</td></tr><tr><td align="left">4</td><td align="left"><strong>public virtual void Enqueue( object obj );</strong> 向 Queue 的末尾添加一个对象。</td></tr><tr><td align="left">5</td><td align="left"><strong>public virtual object[] ToArray();</strong> 复制 Queue 到一个新的数组中。</td></tr><tr><td align="left">6</td><td align="left"><strong>public virtual void TrimToSize();</strong> 设置容量为 Queue 中元素的实际个数。</td></tr></tbody></table><h4 id="3-Stack类"><a href="#3-Stack类" class="headerlink" title="3.Stack类"></a><strong>3.Stack类</strong></h4><p>代表了一个<strong>先进后出</strong>的对象集合</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Count</td><td align="left">获取 Stack 中包含的元素个数。</td></tr></tbody></table><table><thead><tr><th align="left">序号</th><th align="left">方法名 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>public virtual void Clear();</strong> 从 Stack 中移除所有的元素。</td></tr><tr><td align="left">2</td><td align="left"><strong>public virtual bool Contains( object obj );</strong> 判断某个元素是否在 Stack 中。</td></tr><tr><td align="left">3</td><td align="left"><strong>public virtual object Peek();</strong> 返回在 Stack 的顶部的对象，但不移除它。</td></tr><tr><td align="left">4</td><td align="left"><strong>public virtual object Pop();</strong> 移除并返回在 Stack 的顶部的对象。</td></tr><tr><td align="left">5</td><td align="left"><strong>public virtual void Push( object obj );</strong> 向 Stack 的顶部添加一个对象。</td></tr><tr><td align="left">6</td><td align="left"><strong>public virtual object[] ToArray();</strong> 复制 Stack 到一个新的数组中。</td></tr></tbody></table><h4 id="4-Hashtable类"><a href="#4-Hashtable类" class="headerlink" title="4.Hashtable类"></a><strong>4.Hashtable类</strong></h4><p>Hashtable 类代表了一系列基于键的哈希代码组织起来的键&#x2F;值对。它使用键来访问集合中的元素。</p><p>当您使用键访问元素时，则使用哈希表，而且您可以识别一个有用的键值。哈希表中的每一项都有一个键&#x2F;值对。键用于访问集合中的项目。</p><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Count</td><td align="left">获取 Hashtable 中包含的键值对个数。</td></tr><tr><td align="left">IsFixedSize</td><td align="left">获取一个值，表示 Hashtable 是否具有固定大小。</td></tr><tr><td align="left">IsReadOnly</td><td align="left">获取一个值，表示 Hashtable 是否只读。</td></tr><tr><td align="left">Item</td><td align="left">获取或设置与指定的键相关的值。</td></tr><tr><td align="left">Keys</td><td align="left">获取一个 ICollection，包含 Hashtable 中的键。</td></tr><tr><td align="left">Values</td><td align="left">获取一个 ICollection，包含 Hashtable 中的值。</td></tr></tbody></table><table><thead><tr><th align="left">序号</th><th align="left">方法名 &amp; 描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>public virtual void Add( object key, object value );</strong> 向 Hashtable 添加一个带有指定的键和值的元素。</td></tr><tr><td align="left">2</td><td align="left"><strong>public virtual void Clear();</strong> 从 Hashtable 中移除所有的元素。</td></tr><tr><td align="left">3</td><td align="left"><strong>public virtual bool ContainsKey( object key );</strong> 判断 Hashtable 是否包含指定的键。</td></tr><tr><td align="left">4</td><td align="left"><strong>public virtual bool ContainsValue( object value );</strong> 判断 Hashtable 是否包含指定的值。</td></tr><tr><td align="left">5</td><td align="left"><strong>public virtual void Remove( object key );</strong> 从 Hashtable 中移除带有指定的键的元素。</td></tr></tbody></table><h3 id="泛型集合类"><a href="#泛型集合类" class="headerlink" title="泛型集合类"></a>泛型集合类</h3><h4 id="1-List类"><a href="#1-List类" class="headerlink" title="1.List类"></a>1.List<T>类</h4><h4 id="2-dictionary类"><a href="#2-dictionary类" class="headerlink" title="2.dictionary类"></a>2.dictionary<T>类</h4>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>csharp和lua的学习对比</title>
    <link href="/2024/04/23/csharp%E5%92%8Clua%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%AF%B9%E6%AF%94/"/>
    <url>/2024/04/23/csharp%E5%92%8Clua%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%AF%B9%E6%AF%94/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>C# lua</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lua</title>
    <link href="/2024/04/23/lua/"/>
    <url>/2024/04/23/lua/</url>
    
    <content type="html"><![CDATA[<h1 id="Lua学习之路"><a href="#Lua学习之路" class="headerlink" title="Lua学习之路"></a>Lua学习之路</h1><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>tab &#x3D; {“value1”,”value2”}  –{}表类型从下标1开始</p><p>数字类型只有一个number</p><p>允许匿名函数 function() </p><p>string 的连接用  ..</p><p>string类型遇到 + - 等会自动转化 number</p><p>nil 空 判断中可作false</p><p>boolean   false true</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量转换</p><p> -&gt;string    &#x3D; string.format</p><p>number  &#x3D; tonumber  –(类似”123”)这种，包含不合规字符会nil</p><p>可变参数 …</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">average</span><span class="hljs-params">(...)</span></span><br>   result = <span class="hljs-number">0</span><br>   <span class="hljs-keyword">local</span> <span class="hljs-built_in">arg</span>=&#123;...&#125;<br>   <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>(<span class="hljs-built_in">arg</span>) <span class="hljs-keyword">do</span><br>      result = result + v<br>   <span class="hljs-keyword">end</span><br>   <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;总共传入 &quot;</span> .. <span class="hljs-built_in">select</span>(<span class="hljs-string">&quot;#&quot;</span>,...) .. <span class="hljs-string">&quot; 个数&quot;</span>) <span class="hljs-comment">--select(&quot;#&quot;...)查询可变参数数量</span><br>   <span class="hljs-keyword">return</span> result/<span class="hljs-built_in">select</span>(<span class="hljs-string">&quot;#&quot;</span>,...)<br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;平均值为&quot;</span>,average(<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>))<br></code></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="特殊"><a href="#特殊" class="headerlink" title="特殊"></a>特殊</h4>]]></content>
    
    
    
    <tags>
      
      <tag>游戏开发lua脚本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&#39;设计模式&#39;</title>
    <link href="/2024/04/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/04/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="游戏开发设计模式的使用案例"><a href="#游戏开发设计模式的使用案例" class="headerlink" title="游戏开发设计模式的使用案例"></a>游戏开发设计模式的使用案例</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>思想：对类的构造函数进行私有化，提供一个静态类，并且封装好对外调用的静态数据以及函数。使之成为唯一对象。</p><h3 id="监听者模式"><a href="#监听者模式" class="headerlink" title="监听者模式"></a>监听者模式</h3><p>分为广播和监听两种成员。广播要掉用事件的Raise，监听者要有被监听者的引用，并且添加相应的事件。</p><h3 id="订阅发布"><a href="#订阅发布" class="headerlink" title="订阅发布"></a>订阅发布</h3><p>完全解耦合，不需要被监听者的引用。利用事件进行监听和广播。在开发中常用ScriptObject类文件生成相应的UnityAction或者UnityEvent类，用作中间间。都引用该类，实现广播和监听。</p><h4 id="工厂模式。"><a href="#工厂模式。" class="headerlink" title="工厂模式。"></a>工厂模式。</h4>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity3D</title>
    <link href="/2024/03/23/Unity3D/"/>
    <url>/2024/03/23/Unity3D/</url>
    
    <content type="html"><![CDATA[<p>关于2D横板序列帧动画游戏开发记录，重点技术涉及：2D精灵图片切割，Animation序列帧动画生成，Animator动画管理。基础UI设计，事件绑定，键盘事件监听，刚体组件加碰撞体触发器的使用。</p><h1 id="2D横板-像素-动作-闯关游戏设计"><a href="#2D横板-像素-动作-闯关游戏设计" class="headerlink" title="2D横板+像素+动作+闯关游戏设计"></a>2D横板+像素+动作+闯关游戏设计</h1><p>免费素材使用，重点使用2D序列帧动画</p><h2 id="精灵图片切割要点"><a href="#精灵图片切割要点" class="headerlink" title="精灵图片切割要点"></a>精灵图片切割要点</h2><p>图片像素需要根据原始像素进行切割，注意质量要原版质量.</p><h2 id="键盘监听事件"><a href="#键盘监听事件" class="headerlink" title="键盘监听事件"></a>键盘监听事件</h2><p>inputsystem的使用以及跳跃事件和键盘使用的绑定。</p><h2 id="Animation动画制作"><a href="#Animation动画制作" class="headerlink" title="Animation动画制作"></a>Animation动画制作</h2><p>首先创造Animator 进行动画管理，然后找到Animation动画制作pattle，根据面板进行创建，要点在于每秒多少帧，调节这个可以帮助动画的流畅度设计。</p><h2 id="Animator动画切换管理"><a href="#Animator动画切换管理" class="headerlink" title="Animator动画切换管理"></a>Animator动画切换管理</h2><p>Animator是动画的逻辑切换判断，在2D像素风格中，首先要做的就是把切换的等待设置为0，不适用动画切换等待，之后的就是设计每个动画的切换逻辑，特殊的在于触发器的使用，触发器是触发一次变转化一次动作。</p><p>还有一个要点是动画管理的脚本尽量单独使用，方便管理。</p><p>动画还可以设置多个管理层，有覆盖和优先级的设定，下面的weight要调整至1，防止被覆盖。《跳跃+攻击不在一个面板的话需要这样设置，以免不会同时调用》</p><h2 id="事件的绑定-UnityEvent"><a href="#事件的绑定-UnityEvent" class="headerlink" title="事件的绑定 UnityEvent"></a>事件的绑定 UnityEvent</h2><p>Unity 自带了一套事件绑定方法，使用UnityEvent头文件，生成的事件为Public，可以直接在Unity编辑器中进行拖拽绑定，然后使用.来进行调用这一系列事件，事件可以由多个方法组成，可以传入参数，使用的时候利用? 来检查时候有绑定的方法，以免报错。</p><h2 id="Rigbody2D-Collision-刚体加碰撞体"><a href="#Rigbody2D-Collision-刚体加碰撞体" class="headerlink" title="Rigbody2D+Collision 刚体加碰撞体"></a>Rigbody2D+Collision 刚体加碰撞体</h2><p>刚体组件使得物体有了物理性质，碰撞体使得物体有了可以碰撞的条件。碰撞体可以点击Is Trigger 选项，使之成为触发器，这样可以用于检测碰撞或者接触到一定范围的物体。</p><h2 id="IEnumerator-name-协程的使用"><a href="#IEnumerator-name-协程的使用" class="headerlink" title="IEnumerator name 协程的使用"></a>IEnumerator name 协程的使用</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-function">IEnumerator <span class="hljs-title">Onhurt</span>(<span class="hljs-params">Vector2 dir</span>)</span><br>&#123;<br>    rb.AddForce(dir * hurtForce, ForceMode2D.Impulse);<br>    <span class="hljs-function"><span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">WaitForSeconds</span>(<span class="hljs-params"><span class="hljs-number">0.45f</span></span>)</span>;<br>    isHurt = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">//调用</span><br>StartCoroutine(Onhurt(dir));<br></code></pre></td></tr></table></figure><h2 id="UI设计"><a href="#UI设计" class="headerlink" title="UI设计"></a>UI设计</h2><p>锚点的绑定。</p><p>##场景切换<br>利用了GameScenceSo的方法<br>currentLoadedScence.sceneReference.LoadSceneAsync(LoadSceneMode.Additive);</p><h2 id="游戏进度的存储"><a href="#游戏进度的存储" class="headerlink" title="游戏进度的存储"></a>游戏进度的存储</h2><p>ISaveable 接口的设计，实现Savedata 和Loaddata</p><p>Dictionary字典</p><p>保存数据Data 类</p><p>DataDefination设计字典存储物品的ID以及相关数值</p><p>DataManager的设计，单例模式，List保存DataDefination类。循环遍历并且加载数据。</p><p>JsonUtility.ToJson，序列化存储对象。</p><p>JsonUtility,FromJsonOverWrite(SceneToScave,newScene); 反序列化加载</p><p>&#x2F;&#x2F;URL-packges: com.unity&#x2F;nuget.newtonsoft-json     Newtonsoft Json</p>]]></content>
    
    
    
    <tags>
      
      <tag>2D游戏开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/2024/03/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2024/03/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>面试关于数据结构的细节题简单记录。</p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>求节点题：</p><p>1.任何一棵树，总结点树为N，除了根节点，每一个节点都有1条边。设度为0,1,2,3,4,5的节点数分别为n0,n1,n2,n3,n4,n5。</p><p>由边和节点的关系：N-1 &#x3D; 0<em>n0+1</em>n1+2<em>n2+3</em>n3+4<em>n4+5</em>n5；算出总的N &#x3D; 206。</p><p>有度的节点个数为n1+n2+n3+n4+n5 &#x3D;65。那么，叶子结点个数为n0 &#x3D; N- 65 &#x3D; 141。</p><p>2.遍历</p><p>左根右，中序</p><p>根左右，先序</p><p>左右根，后续</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#重点</title>
    <link href="/2024/03/13/CShape%E9%87%8D%E7%82%B9/"/>
    <url>/2024/03/13/CShape%E9%87%8D%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="H1面向对象原则"><a href="#H1面向对象原则" class="headerlink" title="H1面向对象原则"></a>H1面向对象原则</h1><p>封装继承多态</p><p>七大原则</p><p>开闭原则、依赖倒转原则、里氏替换原则、单一职责原则、接口隔离原则、合成复用原则、迪米特法则</p><h1 id="C-重点语法"><a href="#C-重点语法" class="headerlink" title="C#重点语法"></a>C#重点语法</h1><h2 id="基础语句"><a href="#基础语句" class="headerlink" title="基础语句"></a>基础语句</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#">Console.WriteLine(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>Console.Write();<span class="hljs-comment">//仅打印后无换行</span><br><span class="hljs-comment">//区分大小写并且打印string 要用双引号</span><br></code></pre></td></tr></table></figure><ul><li>public：所有对象都可以访问；</li><li>private：对象本身在对象内部可以访问；</li><li>protected：只有该类对象及其子类对象可以访问</li><li>internal：同一个程序集的对象可以访问；</li><li>protected internal：访问限于当前程序集或派生自包含类的类型。</li></ul><h4 id="C-while-判断"><a href="#C-while-判断" class="headerlink" title="C# while 判断()"></a>C# while 判断()</h4><p>while(n–) 非法 必须使用 while(n–!&#x3D;0)</p><h2 id="代码：结构体和类的区别"><a href="#代码：结构体和类的区别" class="headerlink" title="代码：结构体和类的区别"></a>代码：结构体和类的区别</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">Lesson25_</span>面向对象相关_结构体和类的区别<br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;结构体和类的区别&quot;</span>);<br><br>            <span class="hljs-meta">#<span class="hljs-keyword">region</span> 区别概述</span><br>            <span class="hljs-comment">//结构体和类最大的区别是在存储空间上的，因为结构体是值，类是引用，</span><br>            <span class="hljs-comment">//因此他们的存储位置一个在栈上，一个在堆上，</span><br>            <span class="hljs-comment">//通过之前知识点的学习，我相信你能够从此处看出他们在使用的区别——值和引用对象在赋值时的区别。</span><br><br>            <span class="hljs-comment">//结构体和类在使用上很类似，结构体甚至可以用面向对象的思想来形容一类对象。</span><br>            <span class="hljs-comment">//结构体具备着面向对象思想中封装的特性，但是它不具备继承和多态的特性，因此大大减少了它的使用频率。</span><br>            <span class="hljs-comment">//由于结构体不具备继承的特性，所以它不能够使用protected保护访问修饰符。</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">region</span> 细节区别</span><br>            <span class="hljs-comment">//1.结构体是值类型，类是引用类型</span><br>            <span class="hljs-comment">//2.结构体存在栈中，类存在堆中</span><br>            <span class="hljs-comment">//3.结构体成员不能使用protected访问修饰符，而类可以</span><br>            <span class="hljs-comment">//4.结构体成员变量申明不能指定初始值，而类可以</span><br>            <span class="hljs-comment">//5.结构体不能申明无参的构造函数，而类可以</span><br>            <span class="hljs-comment">//6.结构体申明有参构造函数后，无参构造不会被顶掉</span><br>            <span class="hljs-comment">//7.结构体不能申明析构函数，而类可以</span><br>            <span class="hljs-comment">//8.结构体不能被继承，而类可以</span><br>            <span class="hljs-comment">//9.结构体需要在构造函数中初始化所有成员变量，而类随意</span><br>            <span class="hljs-comment">//10.结构体不能被静态static修饰（不存在静态结构体），而类可以</span><br>            <span class="hljs-comment">//11.结构体不能在自己内部申明和自已一样的结构体变量，而类可以</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">region</span> 结构体的特别之处</span><br>            <span class="hljs-comment">//结构体可以继承 接口 因为接口是行为的抽象</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">region</span> 如何选择结构体和类</span><br>            <span class="hljs-comment">//1.想要用继承和多态时，直接淘汰结构体，比如玩家、怪物等等</span><br>            <span class="hljs-comment">//2.对象是数据集合时，优先考虑结构体，比如位置、坐标等等</span><br>            <span class="hljs-comment">//3.从值类型和引用类型赋值时的区别上去考虑，比如经常被赋值传递的对象，并且</span><br>            <span class="hljs-comment">//改变赋值对象，原对象不想跟着变化时，就用结构体。比如坐标、向量、旋转等等</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">Lesson26_</span>面向对象相关_抽象类和接口的区别<br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;抽象类和接口的区别&quot;</span>);<br><br>            <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识回顾</span><br>            <span class="hljs-comment">//抽象类和抽象方法</span><br>            <span class="hljs-comment">//abstract修饰的类和方法</span><br>            <span class="hljs-comment">//抽象类 不能实例化</span><br>            <span class="hljs-comment">//抽象方法只能在抽象类中申明 是个纯虚方法 必须在子类中实现</span><br><br>            <span class="hljs-comment">//接口</span><br>            <span class="hljs-comment">//interface 自定义类型</span><br>            <span class="hljs-comment">//是行为的抽象</span><br>            <span class="hljs-comment">//不包含成员变量</span><br>            <span class="hljs-comment">//仅包含方法、属性、索引器、事件，成员都不能实现，建议不写访问修饰符，默认public</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 相同点</span><br>            <span class="hljs-comment">//1.都可以被继承</span><br>            <span class="hljs-comment">//2.都不能直接实例化</span><br>            <span class="hljs-comment">//3.都可以包含方法申明</span><br>            <span class="hljs-comment">//4.子类必须实现未实现的方法</span><br>            <span class="hljs-comment">//5.都遵循里氏替换原则</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 区别</span><br>            <span class="hljs-comment">//1.抽象类中可以有构造函数；接口中不能</span><br>            <span class="hljs-comment">//2.抽象类只能被单一继承；接口可以被继承多个</span><br>            <span class="hljs-comment">//3.抽象类中可以有成员变量；接口中不能</span><br>            <span class="hljs-comment">//4.抽象类中可以申明成员方法，虚方法，抽象方法，静态方法；接口中只能申明没有实现的抽象方法</span><br>            <span class="hljs-comment">//5.抽象类方法可以使用访问修饰符；接口中建议不写，默认public</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">region</span> 如何选择抽象类和接口</span><br>            <span class="hljs-comment">//表示对象的用抽象类，表示行为拓展的用接口</span><br>            <span class="hljs-comment">//不同对象拥有的共同行为，我们往往可以使用接口来实现</span><br>            <span class="hljs-comment">//举个例子：</span><br>            <span class="hljs-comment">//动物是一类对象，我们自然会选择抽象类；而飞翔是一个行为，我们自然会选择接口。</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/image/Unity3D/1713350961262.png" alt="1713350961262"></p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">Lesson8_</span>练习题<br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;类型转换——显示转换练习题&quot;</span>);<br><br>            <span class="hljs-meta">#<span class="hljs-keyword">region</span> 练习题一</span><br>            <span class="hljs-comment">//显示类型转换有几种方式？他们分别是什么，请举例说明？</span><br>            <span class="hljs-comment">// 1.括号强转 数值之间的转换 低精度 装 高精度</span><br>            <span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">long</span> l = <span class="hljs-number">1</span>;<br>            i = (<span class="hljs-built_in">int</span>)l;<br><br>            <span class="hljs-built_in">float</span> f = <span class="hljs-number">1.1f</span>;<br>            <span class="hljs-built_in">double</span> d = <span class="hljs-number">1.231231231231231231231</span>;<br>            f = (<span class="hljs-built_in">float</span>)d;<br>            <span class="hljs-comment">// 2.Parse法 把字符串 转成 对应的类型 变量类型.Parse(字符串)</span><br>            i = <span class="hljs-built_in">int</span>.Parse(<span class="hljs-string">&quot;123&quot;</span>);<br>            <span class="hljs-comment">// 3.Convert法</span><br>            i = Convert.ToInt32(<span class="hljs-number">12.23123</span>);<br>            i = Convert.ToInt32(<span class="hljs-string">&quot;123123&quot;</span>);<br><br>            <span class="hljs-built_in">string</span> str = Convert.ToString(<span class="hljs-number">123123</span>);<br>            <span class="hljs-comment">// 4.toString法</span><br>            str = <span class="hljs-number">1.</span>ToString();<br>            str = <span class="hljs-number">1.23123f</span>.ToString();<br>            <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">region</span> 练习题二</span><br>            <span class="hljs-comment">//请将24069转成字符，并打印</span><br><br>            <span class="hljs-built_in">char</span> c = (<span class="hljs-built_in">char</span>)<span class="hljs-number">24069</span>;<br>            Console.WriteLine(c);<br><br>            c = Convert.ToChar(<span class="hljs-number">24069</span>);<br>            Console.WriteLine(c);<br><br>            <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">region</span> 练习题三</span><br>            <span class="hljs-comment">//提示用户输入姓名、语文、数学、英语成绩，并将输入的3门成绩用整形变量存储</span><br>            Console.WriteLine(<span class="hljs-string">&quot;请输入你的姓名&quot;</span>);<br>            <span class="hljs-comment">//通过字符串变量 把输入内容存起来</span><br>            <span class="hljs-built_in">string</span> str2 = Console.ReadLine();<br><br>            Console.WriteLine(<span class="hljs-string">&quot;请输入你的语文成绩&quot;</span>);<br>            str2 = Console.ReadLine();<br><br>            <span class="hljs-comment">//再把字符串转为 想要的类型</span><br>            <span class="hljs-built_in">int</span> yuWen = <span class="hljs-built_in">int</span>.Parse(str2);<br>            <span class="hljs-comment">//Console.WriteLine(&quot;你的语文成绩：&quot; + yuWen);</span><br><br>            Console.WriteLine(<span class="hljs-string">&quot;请输入你的数学成绩&quot;</span>);<br>            str2 = Console.ReadLine();<br>            <span class="hljs-built_in">int</span> shuXue = <span class="hljs-built_in">int</span>.Parse(str2);<br>            <span class="hljs-comment">//Console.WriteLine(&quot;你的数学成绩：&quot; + shuXue);</span><br><br>            Console.WriteLine(<span class="hljs-string">&quot;请输入你的英语成绩&quot;</span>);<br>            str2 = Console.ReadLine();<br>            <span class="hljs-built_in">int</span> yingYu = <span class="hljs-built_in">int</span>.Parse(str2);<br>            <span class="hljs-comment">//Console.WriteLine(&quot;你的英语成绩：&quot; + yingYu);</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><code class="hljs Csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">Lesson7_</span>类型转换_隐式转换_<br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;类型转换——隐式转换&quot;</span>);<br>            <span class="hljs-comment">// 什么是类型转换</span><br><br>            <span class="hljs-comment">// 类型转换 就是不同变量类型之间的相互转换</span><br><br>            <span class="hljs-comment">// 隐式转换的基本规则——&gt;不同类型之间自动转换</span><br>            <span class="hljs-comment">// 大范围装小范围</span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 相同大类型之间的转换</span><br><br>            <span class="hljs-comment">//有符号  long——&gt;int——&gt;short——&gt;sbyte</span><br>            <span class="hljs-built_in">long</span> l = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">short</span> s = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">sbyte</span> sb = <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//隐式转换 int隐式转换成了long</span><br>            <span class="hljs-comment">//可以用大范围 装小范围的 类型 （隐式转换）</span><br>            l = i;<br>            <span class="hljs-comment">//不能够用小范围的类型去装在大范围的类型</span><br>            <span class="hljs-comment">//i = l;</span><br>            l = i;<br>            l = s;<br>            l = sb;<br>            i = s;<br>            s = sb;<br><br>            <span class="hljs-comment">//无符号 ulong——&gt;uint——&gt;ushort——&gt;byte</span><br>            <span class="hljs-built_in">ulong</span> ul = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">uint</span> ui = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">ushort</span> us = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">byte</span> b = <span class="hljs-number">1</span>;<br><br>            ul = ui;<br>            ul = us;<br>            ul = b;<br>            ui = us;<br>            ui = b;<br>            us = b;<br><br>            <span class="hljs-comment">//浮点数  decimal    double——&gt;float</span><br>            <span class="hljs-built_in">decimal</span> de = <span class="hljs-number">1.1</span>m;<br>            <span class="hljs-built_in">double</span> d = <span class="hljs-number">1.1</span>;<br>            <span class="hljs-built_in">float</span> f = <span class="hljs-number">1.1f</span>;<br>            <span class="hljs-comment">//decimal这个类型 没有办法用隐式转换的形式 去存储 double和float</span><br>            <span class="hljs-comment">//de = d;</span><br>            <span class="hljs-comment">//de = f;</span><br>            <span class="hljs-comment">//float 是可以隐式转换成 double</span><br>            d = f;<br><br>            <span class="hljs-comment">//特殊类型  bool char string</span><br>            <span class="hljs-comment">// 他们之间 不存在隐式转换</span><br>            <span class="hljs-built_in">bool</span> bo = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">char</span> c = <span class="hljs-string">&#x27;A&#x27;</span>;<br>            <span class="hljs-built_in">string</span> str = <span class="hljs-string">&quot;123123&quot;</span>;<br><br>            <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 不同大类型之间的转换</span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">region</span> 无符号和有符号之间</span><br>            <span class="hljs-comment">//无符号 不能装负数的</span><br>            <span class="hljs-built_in">byte</span> b2 = <span class="hljs-number">1</span>; <span class="hljs-comment">//0~255</span><br>            <span class="hljs-built_in">ushort</span> us2 = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">uint</span> ui2 = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">ulong</span> ul2 = <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//有符号</span><br>            <span class="hljs-built_in">sbyte</span> sb2 = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">short</span> s2 = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">int</span> i2 = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">long</span> l2 = <span class="hljs-number">1</span>;<br><br>            <span class="hljs-comment">//无符号装有符号 </span><br>            <span class="hljs-comment">// 有符号的变量 是不能够 隐式转换成 无符号的</span><br>            <span class="hljs-comment">//b2 = sb2;</span><br>            <span class="hljs-comment">//us2 = sb2;</span><br>            <span class="hljs-comment">//ul2 = sb2;</span><br><br>            <span class="hljs-comment">//有符号装无符号 </span><br>            <span class="hljs-comment">// 有符号变量 是可以 装 无符号变量的 前提是 范围一定要是涵盖的 存在隐式转换</span><br>            <span class="hljs-comment">//i2 = ui2;//因为 有符号的变量 可能会超过 这个无符号变量的范围</span><br>            i2 = b2;<span class="hljs-comment">// 因为 有符号的变量 不管是多少 都在 无符号变量的范围内</span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">region</span> 浮点数和整数（有、无符号）之间</span><br>            <span class="hljs-comment">//浮点数装整数 整形转为浮点数 是存在隐式转换的</span><br>            <span class="hljs-built_in">float</span> f2 = <span class="hljs-number">1.1f</span>;<br>            <span class="hljs-built_in">double</span> d2 = <span class="hljs-number">1.1</span>;<br>            <span class="hljs-built_in">decimal</span> de2 = <span class="hljs-number">1.1</span>m;<br><br>            <span class="hljs-comment">//浮点数 是可以装载任何类型的 整数的</span><br>            f2 = l2;<br>            f2 = i2;<br>            f2 = s2;<br>            f2 = sb2;<br><br>            f2 = ul2;<br>            f2 = ui2;<br>            f2 = us2;<br>            f2 = b2;<br><br>            f2 = <span class="hljs-number">10000000000000000000</span>;<br>            Console.WriteLine(f2);<br><br>            <span class="hljs-comment">//decimal 不能隐式存储 float和double</span><br>            <span class="hljs-comment">//但是它可以隐式的存储整形</span><br>            de = l2;<br>            de = ul2;<br><br>            <span class="hljs-comment">// double ——&gt; float ——&gt; 所有整形（无符号、有符号）</span><br>            <span class="hljs-comment">// decimal ——&gt; 所有整形（无符号、有符号）</span><br><br>            <span class="hljs-comment">//整数装浮点数 整数是不能隐式存储 浮点数  因为 整数 不能存小数</span><br>            <span class="hljs-comment">//i2 = f2;</span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">region</span> 特殊类型和其它类型之间</span><br><br>            <span class="hljs-comment">//bool bool没有办法和其它类型 相互隐式转换</span><br>            <span class="hljs-built_in">bool</span> bo2 = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">char</span> c2 = <span class="hljs-string">&#x27;A&#x27;</span>;<br>            <span class="hljs-built_in">string</span> str2 = <span class="hljs-string">&quot;1231&quot;</span>;<br>            <span class="hljs-comment">//bo2 = i2;</span><br>            <span class="hljs-comment">//bo2 = ui2;</span><br>            <span class="hljs-comment">//bo2 = f2;</span><br><br>            <span class="hljs-comment">//i2 = bo2;</span><br>            <span class="hljs-comment">//ui2 = bo2;</span><br>            <span class="hljs-comment">//f2 = bo2;</span><br><br>            <span class="hljs-comment">//bo2 = c2;</span><br>            <span class="hljs-comment">//c2 = bo2;</span><br>            <span class="hljs-comment">//bo2 = str2;</span><br>            <span class="hljs-comment">//str2 = bo2;</span><br><br>            <span class="hljs-comment">//char char 没有办法隐式的存储 其它类型的变量</span><br>            <span class="hljs-comment">//c2 = i2;</span><br>            <span class="hljs-comment">//c2 = f2;</span><br>            <span class="hljs-comment">//c2 = ui2;</span><br>            <span class="hljs-comment">//c2 = str2;</span><br><br>            <span class="hljs-comment">//char类型 可以隐式的转换成 整形和浮点型</span><br>            <span class="hljs-comment">//char隐式转换成 数值类型是 </span><br>            <span class="hljs-comment">//对应的数字 其实是一个 ASCII码 </span><br>            <span class="hljs-comment">// 计算机里面存储 2进制</span><br>            <span class="hljs-comment">// 字符 中文 英文 标点符号 在计算机中都是一个数字</span><br>            <span class="hljs-comment">// 一个字符 对应一个数字 ASCII码就是一种对应关系</span><br>            i2 = c2;<br>            Console.WriteLine(i2);<br>            f2 = c2;<br>            Console.WriteLine(f2);<br>            ui2 = c2;<br>            Console.WriteLine(ui2);<br><br>            <span class="hljs-comment">//str2 = c2;</span><br><br>            <span class="hljs-comment">//string 类型 无法和其它类型进行隐式转换</span><br>            <span class="hljs-comment">//i2 = str2;</span><br>            <span class="hljs-comment">//ui2 = str2;</span><br>            <span class="hljs-comment">//f2 = str2;</span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br><br>            <span class="hljs-comment">// 总结 隐式转换 规则</span><br>            <span class="hljs-comment">// 高精度（大范围）装低精度（小范围）</span><br>            <span class="hljs-comment">// double ——&gt; float ——&gt; 整数（无符号、有符号）——&gt;char</span><br>            <span class="hljs-comment">// decimal ——&gt; 整数（无符号、有符号）——&gt;char</span><br>            <span class="hljs-comment">// string 和 bool 不参与隐式转换规则的</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">Lesson22_</span>迭代器<br>&#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 迭代器是什么</span><br>    <span class="hljs-comment">//迭代器（iterator）有时又称光标（cursor）</span><br>    <span class="hljs-comment">//是程序设计的软件设计模式</span><br>    <span class="hljs-comment">//迭代器模式提供一个方法顺序访问一个聚合对象中的各个元素</span><br>    <span class="hljs-comment">//而又不暴露其内部的标识</span><br><br>    <span class="hljs-comment">//在表现效果上看</span><br>    <span class="hljs-comment">//是可以在容器对象（例如链表或数组）上遍历访问的接口</span><br>    <span class="hljs-comment">//设计人员无需关心容器对象的内存分配的实现细节</span><br>    <span class="hljs-comment">//可以用foreach遍历的类，都是实现了迭代器的</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 标准迭代器的实现方法</span><br>    <span class="hljs-comment">//关键接口：IEnumerator,IEnumerable</span><br>    <span class="hljs-comment">//命名空间：using System.Collections;</span><br>    <span class="hljs-comment">//可以通过同时继承IEnumerable和IEnumerator实现其中的方法</span><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">CustomList</span> : <span class="hljs-title">IEnumerable</span>, <span class="hljs-title">IEnumerator</span><br>    &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span>[] list;<br>        <span class="hljs-comment">//从-1开始的光标 用于表示 数据得到了哪个位置</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> position = <span class="hljs-number">-1</span>;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomList</span>()</span><br>        &#123;<br>            list = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span> &#125;;<br>        &#125;<br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> IEnumerable</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerator <span class="hljs-title">GetEnumerator</span>()</span><br>        &#123;<br>            Reset();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">object</span> Current<br>        &#123;<br>            <span class="hljs-keyword">get</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> list[position];<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">MoveNext</span>()</span><br>        &#123;<br>            <span class="hljs-comment">//移动光标</span><br>            ++position;<br>            <span class="hljs-comment">//是否溢出 溢出就不合法</span><br>            <span class="hljs-keyword">return</span> position &lt; list.Length;<br>        &#125;<br><br>        <span class="hljs-comment">//reset是重置光标位置 一般写在获取 IEnumerator对象这个函数中</span><br>        <span class="hljs-comment">//用于第一次重置光标位置</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Reset</span>()</span><br>        &#123;<br>            position = <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 用yield return 语法糖实现迭代器</span><br>    <span class="hljs-comment">//yield return 是C#提供给我们的语法糖</span><br>    <span class="hljs-comment">//所谓语法糖，也称糖衣语法</span><br>    <span class="hljs-comment">//主要作用就是将复杂逻辑简单化，可以增加程序的可读性</span><br>    <span class="hljs-comment">//从而减少程序代码出错的机会</span><br><br>    <span class="hljs-comment">//关键接口：IEnumerable</span><br>    <span class="hljs-comment">//命名空间：using System.Collections;</span><br>    <span class="hljs-comment">//让想要通过foreach遍历的自定义类实现接口中的方法GetEnumerator即可</span><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">CustomList2</span> : <span class="hljs-title">IEnumerable</span><br>    &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span>[] list;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomList2</span>()</span><br>        &#123;<br>            list = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span> &#125;;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerator <span class="hljs-title">GetEnumerator</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; list.Length; i++)<br>            &#123;<br>                <span class="hljs-comment">//yield关键字 配合迭代器使用</span><br>                <span class="hljs-comment">//可以理解为 暂时返回 保留当前的状态</span><br>                <span class="hljs-comment">//一会还会在回来</span><br>                <span class="hljs-comment">//C#的语法糖</span><br>                <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> list[i];<br>            &#125;<br>            <span class="hljs-comment">//yield return list[0];</span><br>            <span class="hljs-comment">//yield return list[1];</span><br>            <span class="hljs-comment">//yield return list[2];</span><br>            <span class="hljs-comment">//yield return list[3];</span><br>            <span class="hljs-comment">//yield return list[4];</span><br>            <span class="hljs-comment">//yield return list[5];</span><br>            <span class="hljs-comment">//yield return list[6];</span><br>            <span class="hljs-comment">//yield return list[7];</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点四 用yield return 语法糖为泛型类实现迭代器</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">CustomList</span>&lt;<span class="hljs-title">T</span>&gt; : <span class="hljs-title">IEnumerable</span><br>    &#123;<br>        <span class="hljs-keyword">private</span> T[] array;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomList</span>(<span class="hljs-params"><span class="hljs-keyword">params</span> T[] array</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">this</span>.array = array;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerator <span class="hljs-title">GetEnumerator</span>()</span><br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; array.Length; i++)<br>            &#123;<br>                <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> array[i];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;迭代器&quot;</span>);<br><br>            CustomList list = <span class="hljs-keyword">new</span> CustomList();<br><br>            <span class="hljs-comment">//foreach本质 </span><br>            <span class="hljs-comment">//1.先获取in后面这个对象的 IEnumerator</span><br>            <span class="hljs-comment">//  会调用对象其中的GetEnumerator方法 来获取</span><br>            <span class="hljs-comment">//2.执行得到这个IEnumerator对象中的 MoveNext方法</span><br>            <span class="hljs-comment">//3.只要MoveNext方法的返回值时true 就会去得到Current</span><br>            <span class="hljs-comment">//  然后复制给 item</span><br>            <span class="hljs-comment">//foreach (int item in list)</span><br>            <span class="hljs-comment">//&#123;</span><br>            <span class="hljs-comment">//    Console.WriteLine(item);</span><br>            <span class="hljs-comment">//&#125;</span><br><br>            <span class="hljs-comment">//foreach (int item in list)</span><br>            <span class="hljs-comment">//&#123;</span><br>            <span class="hljs-comment">//    Console.WriteLine(item);</span><br>            <span class="hljs-comment">//&#125;</span><br><br>            CustomList&lt;<span class="hljs-built_in">string</span>&gt; list2 = <span class="hljs-keyword">new</span> CustomList&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;123&quot;</span>,<span class="hljs-string">&quot;321&quot;</span>,<span class="hljs-string">&quot;333&quot;</span>,<span class="hljs-string">&quot;555&quot;</span>);<br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">string</span> item <span class="hljs-keyword">in</span> list2)<br>            &#123;<br>                Console.WriteLine(item);<br>            &#125;<br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">string</span> item <span class="hljs-keyword">in</span> list2)<br>            &#123;<br>                Console.WriteLine(item);<br>            &#125;<br><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//总结：</span><br><span class="hljs-comment">//迭代器就是可以让我们在外部直接通过foreach遍历对象中元素而不需要了解其结构</span><br><span class="hljs-comment">//主要的两种方式</span><br><span class="hljs-comment">//1.传统方式 继承两个接口 实现里面的方法</span><br><span class="hljs-comment">//2.用语法糖 yield return 去返回内容 只需要继承一个接口即可</span><br><br></code></pre></td></tr></table></figure><h1 id="C-进阶"><a href="#C-进阶" class="headerlink" title="C#进阶"></a>C#进阶</h1><h2 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections;<br><span class="hljs-keyword">using</span> System.Reflection.PortableExecutable;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">Lesson4_Hashtable</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Hashtable&quot;</span>);<br><br>            <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点一 Hashtalbe的本质</span><br>            <span class="hljs-comment">//Hashtable（又称散列表） 是基于键的哈希代码组织起来的 键/值对</span><br>            <span class="hljs-comment">//它的主要作用是提高数据查询的效率</span><br>            <span class="hljs-comment">//使用键来访问集合中的元素</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点二 申明</span><br>            <span class="hljs-comment">//需要引用命名空间 System.Collections</span><br>            Hashtable hashtable = <span class="hljs-keyword">new</span> Hashtable();<br>            <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点三 增删查改</span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">region</span> 增</span><br>            hashtable.Add(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;123&quot;</span>);<br>            hashtable.Add(<span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-number">2</span>);<br>            hashtable.Add(<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>            hashtable.Add(<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>            <span class="hljs-comment">//注意：不能出现相同键</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">region</span> 删</span><br>            <span class="hljs-comment">//1.只能通过键去删除</span><br>            hashtable.Remove(<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//2.删除不存在的键 没反应</span><br>            hashtable.Remove(<span class="hljs-number">2</span>);<br><br>            <span class="hljs-comment">//3.或者直接清空</span><br>            hashtable.Clear();<br>            hashtable.Add(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;123&quot;</span>);<br>            hashtable.Add(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;1234&quot;</span>);<br>            hashtable.Add(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;123&quot;</span>);<br>            hashtable.Add(<span class="hljs-string">&quot;123123&quot;</span>, <span class="hljs-number">12</span>);<br>            <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">region</span> 查</span><br>            <span class="hljs-comment">//1.通过键查看值</span><br>            <span class="hljs-comment">//  找不到会返回空</span><br>            Console.WriteLine(hashtable[<span class="hljs-number">1</span>]);<br>            Console.WriteLine(hashtable[<span class="hljs-number">4</span>]);<span class="hljs-comment">//null</span><br>            Console.WriteLine(hashtable[<span class="hljs-string">&quot;123123&quot;</span>]);<br><br>            <span class="hljs-comment">//2.查看是否存在</span><br>            <span class="hljs-comment">//根据键检测</span><br>            <span class="hljs-keyword">if</span>( hashtable.Contains(<span class="hljs-number">2</span>) )<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;存在键为2的键值对&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span>( hashtable.ContainsKey(<span class="hljs-number">2</span>) )<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;存在键为2的键值对&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-comment">//根据值检测</span><br>            <span class="hljs-keyword">if</span>( hashtable.ContainsValue(<span class="hljs-number">12</span>) )<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;存在值为12的键值对&quot;</span>);<br>            &#125;<br>            <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">region</span> 改</span><br>            <span class="hljs-comment">//只能改 键对应的值内容 无法修改键</span><br>            Console.WriteLine(hashtable[<span class="hljs-number">1</span>]);<br>            hashtable[<span class="hljs-number">1</span>] = <span class="hljs-number">100.5f</span>;<br>            Console.WriteLine(hashtable[<span class="hljs-number">1</span>]);<br>            <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点四 遍历</span><br>            <span class="hljs-comment">//得到键值对 对数</span><br>            Console.WriteLine(hashtable.Count);<br><br>            <span class="hljs-comment">//1.遍历所有键</span><br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">object</span> item <span class="hljs-keyword">in</span> hashtable.Keys)<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;键：&quot;</span>+item);<br>                Console.WriteLine(<span class="hljs-string">&quot;值：&quot;</span>+hashtable[item]);<br>            &#125;<br><br>            <span class="hljs-comment">//2.遍历所有值</span><br>            <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">object</span> item <span class="hljs-keyword">in</span> hashtable.Values)<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;值：&quot;</span> + item);<br>            &#125;<br>         <br><br>            <span class="hljs-comment">//3.键值对一起遍历</span><br>            <span class="hljs-keyword">foreach</span> (DictionaryEntry item <span class="hljs-keyword">in</span> hashtable)<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;键：&quot;</span> + item.Key + <span class="hljs-string">&quot;值：&quot;</span> + item.Value);<br>            &#125;<br><br>            <span class="hljs-comment">//4.迭代器遍历法</span><br>         <span class="hljs-comment">/*   foreach (DictionaryEntry item in hashtable)</span><br><span class="hljs-comment">            &#123;</span><br><span class="hljs-comment">                Console.WriteLine();</span><br><span class="hljs-comment">            &#125;*/</span><br><br>            IDictionaryEnumerator myEnumerator = hashtable.GetEnumerator();<br>            <span class="hljs-built_in">bool</span> flag = myEnumerator.MoveNext();<br>            <span class="hljs-keyword">while</span> (flag)<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;键：&quot;</span> + myEnumerator.Key + <span class="hljs-string">&quot;值：&quot;</span> + myEnumerator.Value);<br>                flag = myEnumerator.MoveNext();<br>            &#125;<br>            <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>            <span class="hljs-meta">#<span class="hljs-keyword">region</span> 知识点五 装箱拆箱</span><br>            <span class="hljs-comment">//由于用万物之父来存储数据，自然存在装箱拆箱</span><br>            <span class="hljs-comment">//当往其中进行值类型存储时就是在装箱</span><br>            <span class="hljs-comment">//当将值类型对象取出来转换使用时，就存在拆箱</span><br>            <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++</title>
    <link href="/2024/03/11/c++/"/>
    <url>/2024/03/11/c++/</url>
    
    <content type="html"><![CDATA[<p>2024年对于C++部分重点梳理记录</p><p>开始学习~</p><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="常量const和constexpr"><a href="#常量const和constexpr" class="headerlink" title="常量const和constexpr"></a>常量const和constexpr</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> valuename = initvalue;<span class="hljs-comment">//声明不可修改常量存储同变量一样，但不可修改。</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">valuename</span><span class="hljs-params">()</span> </span>= &#123;<span class="hljs-keyword">return</span> valuename * <span class="hljs-number">2</span>;&#125; <span class="hljs-comment">//声明不可修改常量函数，类似函数。</span><br></code></pre></td></tr></table></figure><h3 id="枚举enum"><a href="#枚举enum" class="headerlink" title="枚举enum"></a>枚举enum</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">CardinalDirections</span>&#123;<br>North = <span class="hljs-number">25</span>,<br>South,<br>East,<br>West<br>&#125;;<br><span class="hljs-comment">//cout&lt;&lt;South输出的值为26;</span><br></code></pre></td></tr></table></figure><h3 id="C-左值-右值引用"><a href="#C-左值-右值引用" class="headerlink" title="C++左值&#x2F;右值引用"></a>C++左值&#x2F;右值引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>; <span class="hljs-comment">//a 是作，1是右值</span><br><span class="hljs-type">int</span>&amp;&amp; b  = <span class="hljs-number">1</span> ;<span class="hljs-comment">// 右值引用</span><br><span class="hljs-type">int</span>&amp; c = <span class="hljs-number">1</span>; <span class="hljs-comment">//左值引用</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; d = <span class="hljs-number">1</span> ; <span class="hljs-comment">//万能引用</span><br><span class="hljs-comment">//左值，不会因为运算后而消亡，有存储地址。 右值，临时常量。</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;&amp; x)</span></span>&#123;<br>&#125;<span class="hljs-comment">//无法接受左值</span><br><br>Tamplate &lt;T&amp;&amp; x&gt;<br><span class="hljs-built_in">fun1</span>(<span class="hljs-type">int</span>&amp; x)&#123;<br><span class="hljs-comment">//左值引用</span><br>&#125;<br><span class="hljs-built_in">fun1</span>(<span class="hljs-type">int</span>&amp;&amp; x)&#123;<br><span class="hljs-comment">//右值引用</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T&amp;&amp; x)</span></span>&#123; <span class="hljs-comment">//可以接受左右值</span><br><span class="hljs-built_in">fun1</span>(std::forward(x))<span class="hljs-comment">//完美转发左右值/保持其值类型</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ STL</title>
    <link href="/2024/03/07/C++-STL/"/>
    <url>/2024/03/07/C++-STL/</url>
    
    <content type="html"><![CDATA[<h1 id="C-数据类型语法"><a href="#C-数据类型语法" class="headerlink" title="C++数据类型语法"></a>C++数据类型语法</h1><h2 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h2><h4 id="引入头文件"><a href="#引入头文件" class="headerlink" title="引入头文件"></a>引入头文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="unordered-set是什么"><a href="#unordered-set是什么" class="headerlink" title="unordered_set是什么"></a>unordered_set是什么</h4><p>unordered_set 容器，可直译为“无序 set 容器”。即 unordered_set 容器和 set 容器很像，唯一的区别就在于 set 容器会自行对存储的数据进行排序，而 unordered_set 容器不会。</p><h4 id="unordered-set的几个特性："><a href="#unordered-set的几个特性：" class="headerlink" title="unordered_set的几个特性："></a><strong>unordered_set的几个特性：</strong></h4><ol><li>不再以键值对的形式存储数据，而是直接存储数据的值 ；</li><li>容器内部存储的各个元素的值都互不相等，且不能被修改；</li><li>不会对内部存储的数据进行排序</li></ol><h4 id="unordered-set的初始化"><a href="#unordered-set的初始化" class="headerlink" title="unordered_set的初始化"></a>unordered_set的初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">unordered_set&lt;<span class="hljs-type">int</span>&gt; set1;<span class="hljs-comment">//创建</span><br><span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">set2</span><span class="hljs-params">(set1)</span></span>;<span class="hljs-comment">//copy</span><br><span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">set3</span><span class="hljs-params">(set1.begin(), set1.end())</span></span>;<span class="hljs-comment">//使用迭代器构造</span><br><span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">set4</span><span class="hljs-params">(arr,arr+<span class="hljs-number">5</span>)</span></span>;<span class="hljs-comment">//使用数组作为其初值进行构造</span><br><span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">set5</span><span class="hljs-params">(move(set2))</span></span>;<span class="hljs-comment">//移动构造</span><br>unordered_set&lt;<span class="hljs-type">int</span>&gt; set6 &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>&#125;;<span class="hljs-comment">//使用处置列表</span><br></code></pre></td></tr></table></figure><h4 id="unordered-set常用函数"><a href="#unordered-set常用函数" class="headerlink" title="unordered_set常用函数"></a>unordered_set常用函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">set1.<span class="hljs-built_in">empty</span>();<span class="hljs-comment">//判断是否位空 是 True 否 Flase;</span><br>set1.<span class="hljs-built_in">find</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">//查找，//查找2，找到返回迭代器，失败返回end()</span><br>set1.<span class="hljs-built_in">count</span>(<span class="hljs-number">2</span>);<span class="hljs-comment">//返回0 1；</span><br><span class="hljs-comment">//插入元素，返回pair&lt;unordered_set&lt;int&gt;::iterator, bool&gt;</span><br>set1.<span class="hljs-built_in">insert</span>(<span class="hljs-number">3</span>);<br><span class="hljs-comment">//使用initializer_list插入元素</span><br>set1.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;);<br><span class="hljs-comment">//指定插入位置，如果位置正确会减少插入时间，返回指向插入元素的迭代器</span><br>set1.<span class="hljs-built_in">insert</span>(set1.<span class="hljs-built_in">end</span>(), <span class="hljs-number">4</span>);<br><span class="hljs-comment">//使用范围迭代器插入</span><br>set1.<span class="hljs-built_in">insert</span>(set2.<span class="hljs-built_in">begin</span>(), set2.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure><p>关于insert函数的返回值：<br>insert()只传入单个参数（待插入元素）</p><ol><li>会返回一个 pair 对象</li><li>这个 pair 对象包含一个迭代器，以及一个附加的布尔值用来说明插入是否成功</li><li>如果元素被插入，返回的迭代器会指向新元素</li><li>如果没有被插入，迭代器指向阻止插入的元素<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> pr = words.<span class="hljs-built_in">insert</span>(<span class="hljs-string">&quot;ninety&quot;</span>); <span class="hljs-comment">// Returns a pair - an iterator &amp; a bool value</span><br></code></pre></td></tr></table></figure></li></ol><p><strong>insert()传入两个参数（迭代器+待插入元素）</strong></p><ol><li>插入初始化表中的元素</li><li>在这种情况下，什么都没有返回</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">words.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&quot;ten&quot;</span>, <span class="hljs-string">&quot;seven&quot;</span>, <span class="hljs-string">&quot;six&quot;</span>&#125;);  <span class="hljs-comment">// Inserting an initializer list</span><br></code></pre></td></tr></table></figure><p><strong>emplace()函数——插入元素(转移构造)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//使用转移构造函数添加新元素3，比insert效率高</span><br>set1.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">3</span>);<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//删除操作，成功返回1，失败返回0</span><br>set1.<span class="hljs-built_in">erase</span>(<span class="hljs-number">1</span>);<br><span class="hljs-comment">//删除操作，成功返回下一个pair的迭代器</span><br>set1.<span class="hljs-built_in">erase</span>(set1.<span class="hljs-built_in">find</span>(<span class="hljs-number">1</span>));<br><span class="hljs-comment">//删除set1的所有元素，返回指向end的迭代器</span><br>set1.<span class="hljs-built_in">erase</span>(set1.<span class="hljs-built_in">begin</span>(), set1.<span class="hljs-built_in">end</span>());<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>study-linux</title>
    <link href="/2024/03/07/study-linux/"/>
    <url>/2024/03/07/study-linux/</url>
    
    <content type="html"><![CDATA[<h2 id="linux-指令"><a href="#linux-指令" class="headerlink" title="linux-指令"></a>linux-指令</h2>]]></content>
    
    
    
    <tags>
      
      <tag>Study</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my new post</title>
    <link href="/2024/03/07/my-new-post/"/>
    <url>/2024/03/07/my-new-post/</url>
    
    <content type="html"><![CDATA[<h2 id="linux-指令"><a href="#linux-指令" class="headerlink" title="linux 指令"></a>linux 指令</h2><p>密码：1</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/01/23/hello-world/"/>
    <url>/2024/01/23/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
